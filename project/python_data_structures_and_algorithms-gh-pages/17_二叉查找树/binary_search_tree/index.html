<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>17_二叉查找树 - Python 数据结构与算法视频教程</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "17_\u4e8c\u53c9\u67e5\u627e\u6811";
    var mkdocs_page_input_path = "17_\u4e8c\u53c9\u67e5\u627e\u6811/binary_search_tree.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> Python 数据结构与算法视频教程</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../..">课程简介</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../00_课程简介之笨方法学算法/why_and_how_to_learn/">00_课程简介之笨方法学算法</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../01_抽象数据类型和面向对象编程/ADT_OOP/">01_抽象数据类型和面向对象编程</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../02_数组和列表/array_and_list/">02_数组和列表</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../03_链表/linked_list/">03_链表</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../04_队列/queue/">04_队列</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../05_栈/stack/">05_栈</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../06_算法分析/big_o/">06_算法分析</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../07_哈希表/hashtable/">07_哈希表</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../08_字典/dict/">08_字典</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../09_集合/set/">09_集合</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../10_递归/recursion/">10_递归</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../11_线性查找与二分查找/search/">11_线性查找与二分查找</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../12_基本排序算法/basic_sort/">12_基本排序算法</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">13_高级排序算法</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../13_高级排序算法/advanced_sorting/">高级排序算法</a>
                </li>
                <li class="">
                    
    <a class="" href="../../13_高级排序算法/merge_sort/">分治法与归并排序</a>
                </li>
                <li class="">
                    
    <a class="" href="../../13_高级排序算法/quick_sort/">快速排序</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../14_树与二叉树/tree/">14_树与二叉树</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../15_堆与堆排序/heap_and_heapsort/">15_堆和堆排序</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../16_优先级队列/priority_queue/">16_优先级队列</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">17_二叉查找树</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#bst">二叉查找树(BST)</a></li>
    

    <li class="toctree-l2"><a href="#bst_1">BST 定义</a></li>
    

    <li class="toctree-l2"><a href="#bst_2">构造一个 BST</a></li>
    

    <li class="toctree-l2"><a href="#bst_3">BST 操作</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#_1">查找</a></li>
        
            <li><a class="toctree-l3" href="#key">获取最大和最小 key 的节点</a></li>
        
            <li><a class="toctree-l3" href="#_2">插入</a></li>
        
            <li><a class="toctree-l3" href="#_3">删除节点</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#_7">时间复杂度分析</a></li>
    

    <li class="toctree-l2"><a href="#_8">练习题：</a></li>
    

    <li class="toctree-l2"><a href="#_9">延伸阅读</a></li>
    

    <li class="toctree-l2"><a href="#leetcode">Leetcode</a></li>
    

    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../18_图与图的遍历/graph/">18_图与图的遍历</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../19_python内置常用算法和数据结构/builtins/">19_python内置常用算法和数据结构</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../20_面试指南/interview/">20_面试指南</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">Python 数据结构与算法视频教程</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
    
    <li>17_二叉查找树</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="bst">二叉查找树(BST)</h1>
<p>二叉树的一种应用就是来实现堆，今天我们再看看用二叉查找树(Binary Search Tree, BST)。
前面有章节说到了查找操作，包括线性查找、二分查找、哈希查找等，线性查找效率比较低，二分又要求必须是有序的序列，
为了维持有序插入的代价比较高、哈希查找效率很高但是浪费空间。能不能有一种插入和查找都比较快的数据结构呢？二叉查找树就是这样一种结构，可以高效地插入和查询节点。</p>
<h1 id="bst_1">BST 定义</h1>
<p>二叉查找树是这样一种二叉树结构，它的每个节点包含一个 key 和它附带的数据，对于每个内部节点 V：</p>
<ul>
<li>所有 key 小于 V 的都被存储在 V 的左子树</li>
<li>所有 key 大于 V 的都存储在 V 的右子树</li>
</ul>
<p><img alt="" src="../bst.png" /></p>
<p>注意这个限制条件，可别和堆搞混了。说白了就是对于每个内部节点，左子树的 key 都比它小，右子树都比它大。
如果中序遍历(二叉树遍历讲过了)这颗二叉树，你会发现输出的顺序正好是有序的。
我们先来定义一下 BST 的节点结构：</p>
<pre><code class="language-py">class BSTNode(object):
    def __init__(self, key, value, left=None, right=None):
        self.key, self.value, self.left, self.right = key, value, left, right
</code></pre>
<h1 id="bst_2">构造一个 BST</h1>
<p>我们还像之前构造二叉树一样，按照上图构造一个 BST 用来演示：</p>
<pre><code class="language-py">class BST(object):
    def __init__(self, root=None):
        self.root = root

    @classmethod
    def build_from(cls, node_list):
        cls.size = 0
        key_to_node_dict = {}
        for node_dict in node_list:
            key = node_dict['key']
            key_to_node_dict[key] = BSTNode(key, value=key)   # 这里值暂时用 和 key一样的

        for node_dict in node_list:
            key = node_dict['key']
            node = key_to_node_dict[key]
            if node_dict['is_root']:
                root = node
            node.left = key_to_node_dict.get(node_dict['left'])
            node.right = key_to_node_dict.get(node_dict['right'])
            cls.size += 1
        return cls(root)


NODE_LIST = [
    {'key': 60, 'left': 12, 'right': 90, 'is_root': True},
    {'key': 12, 'left': 4, 'right': 41, 'is_root': False},
    {'key': 4, 'left': 1, 'right': None, 'is_root': False},
    {'key': 1, 'left': None, 'right': None, 'is_root': False},
    {'key': 41, 'left': 29, 'right': None, 'is_root': False},
    {'key': 29, 'left': 23, 'right': 37, 'is_root': False},
    {'key': 23, 'left': None, 'right': None, 'is_root': False},
    {'key': 37, 'left': None, 'right': None, 'is_root': False},
    {'key': 90, 'left': 71, 'right': 100, 'is_root': False},
    {'key': 71, 'left': None, 'right': 84, 'is_root': False},
    {'key': 100, 'left': None, 'right': None, 'is_root': False},
    {'key': 84, 'left': None, 'right': None, 'is_root': False},
]
bst = BST.build_from(NODE_LIST)
</code></pre>
<h1 id="bst_3">BST 操作</h1>
<h2 id="_1">查找</h2>
<p>如何查找一个指定的节点呢，根据定义我们知道每个内部节点左子树的 key 都比它小，右子树的 key 都比它大，所以
对于带查找的节点 search_key，从根节点开始，如果 search_key 大于当前 key，就去右子树查找，否则去左子树查找。 一直到当前节点是 None 了说明没找到对应 key。</p>
<p><img alt="" src="../bst_search.png" /></p>
<p>好，撸代码：</p>
<pre><code class="language-py">    def _bst_search(self, subtree, key):
        if subtree is None:   # 没找到
            return None
        elif key &lt; subtree.key:
            return self._bst_search(subtree.left, key)
        elif key &gt; subtree.key:
            return self._bst_search(subtree.right, key)
        else:
            return subtree

    def get(self, key, default=None):
        node = self._bst_search(self.root, key)
        if node is None:
            return default
        else:
            return node.value
</code></pre>
<h2 id="key">获取最大和最小 key 的节点</h2>
<p>其实还按照其定义，最小值就一直向着左子树找，最大值一直向右子树找，递归查找就行。</p>
<pre><code class="language-py">    def _bst_min_node(self, subtree):
        if subtree is None:
            return None
        elif subtree.left is None:   # 找到左子树的头
            return subtree
        else:
            return self._bst_min_node(subtree.left)

    def bst_min(self):
        node = self._bst_min_node(self.root)
        return node.value if node else None
</code></pre>
<h2 id="_2">插入</h2>
<p>插入节点的时候我们需要一直保持 BST 的性质，每次插入一个节点，我们都通过递归比较把它放到正确的位置。
你会发现新节点总是被作为叶子结点插入。（请你思考这是为什么）</p>
<p><img alt="" src="../bst_insert.png" /></p>
<pre><code class="language-py">    def _bst_insert(self, subtree, key, value):
        &quot;&quot;&quot; 插入并且返回根节点

        :param subtree:
        :param key:
        :param value:
        &quot;&quot;&quot;
        if subtree is None:   # 插入的节点一定是根节点，包括 root 为空的情况
            subtree = BSTNode(key, value)
        elif key &lt; subtree.key:
            subtree.left = self._bst_insert(subtree.left, key, value)
        elif key &gt; subtree.key:
            subtree.right = self._bst_insert(subtree.right, key, value)
        return subtree

    def add(self, key, value):
        node = self._bst_search(self.root, key)
        if node is not None:   # 更新已经存在的 key
            node.value = value
            return False
        else:
            self.root = self._bst_insert(self.root, key, value)
            self.size += 1
            return True
</code></pre>
<h2 id="_3">删除节点</h2>
<p>删除操作相比上边的操作要麻烦很多，首先需要定位一个节点，删除节点后，我们需要始终保持 BST 的性质。
删除一个节点涉及到三种情况：</p>
<ul>
<li>节点是叶节点</li>
<li>节点有一个孩子</li>
<li>节点有两个孩子</li>
</ul>
<p>我们分别来看看三种情况下如何删除一个节点：</p>
<h4 id="_4">删除叶节点</h4>
<p>这是最简单的一种情况，只需要把它的父亲指向它的指针设置为 None 就好。</p>
<p><img alt="" src="../bst_remove_leaf.png" /></p>
<h4 id="_5">删除只有一个孩子的节点</h4>
<p>删除有一个孩子的节点时，我们拿掉需要删除的节点，之后把它的父亲指向它的孩子就行，因为根据 BST
左子树都小于节点，右子树都大于节点的特性，删除它之后这个条件依旧满足。</p>
<p><img alt="" src="../bst_remove_node_with_one_child.png" /></p>
<h4 id="_6">删除有两个孩子的内部节点</h4>
<p>假如我们想删除 12 这个节点改怎么做呢？你的第一反应可能是按照下图的方式：</p>
<p><img alt="" src="../remove_interior_replace.png" /></p>
<p>但是这种方式可能会影响树的高度，降低查找的效率。这里我们用另一种非常巧妙的方式。
还记得上边提到的吗，如果你中序遍历 BST 并且输出每个节点的 key，你会发现就是一个有序的数组。
<code>[1 4 12 23 29 37 41 60 71 84 90 100]</code>。这里我们定义两个概念，逻辑前任(predecessor)和后继(successor)，请看下图:</p>
<p><img alt="" src="../predecessor_successor.png" /></p>
<p>12 在中序遍历中的逻辑前任和后继分别是 4 和 23 节点。于是我们还有一种方法来删除 12 这个节点：</p>
<ul>
<li>找到待删除节点 N(12) 的后继节点 S(23)</li>
<li>复制节点 S 到节点 N</li>
<li>从 N 的右子树中删除节点 S，并更新其删除后继节点后的右子树</li>
</ul>
<p>说白了就是找到后继并且替换，这里之所以能保证这种方法是正确的，你会发现替换后依旧是保持了 BST 的性质。
有个问题是如何找到后继节点呢？待删除节点的右子树的最小的节点不就是后继嘛，上边我们已经实现了找到最小 key 的方法了。</p>
<p><img alt="" src="../find_successor.png" /></p>
<p>我们开始编写代码实现，和之前的操作类似，我们还是通过辅助函数的形式来实现，这个递归函数会比较复杂，请你仔细理解:</p>
<pre><code class="language-py">    def _bst_remove(self, subtree, key):
        &quot;&quot;&quot;删除节点并返回根节点&quot;&quot;&quot;
        if subtree is None:
            return None
        elif key &lt; subtree.key:
            subtree.left = self._bst_remove(subtree.left, key)
            return subtree
        elif key &gt; subtree.key:
            subtree.right = self._bst_remove(subtree.right, key)
            return subtree
        else:  # 找到了需要删除的节点
            if subtree.left is None and subtree.right is None:    # 叶节点，返回 None 把其父亲指向它的指针置为 None
                return None
            elif subtree.left is None or subtree.right is None:  # 只有一个孩子
                if subtree.left is not None:
                    return subtree.left   # 返回它的孩子并让它的父亲指过去
                else:
                    return subtree.right
            else:  # 俩孩子，寻找后继节点替换，并从待删节点的右子树中删除后继节点
                successor_node = self._bst_min_node(subtree.right)
                subtree.key, subtree.value = successor_node.key, successor_node.value
                subtree.right = self._bst_remove(subtree.right, successor_node.key)
                return subtree

    def remove(self, key):
        assert key in self
        self.size -= 1
        return self._bst_remove(self.root, key)
</code></pre>
<p>完整代码你可以在本章的 bst.py  找到。
另外推荐一个可以在线演示过程的网址大家可以手动执行下看看效果： https://www.cs.usfca.edu/~galles/visualization/BST.html</p>
<h1 id="_7">时间复杂度分析</h1>
<p>上边介绍的操作时间复杂度和二叉树的形状有关。平均来说时间复杂度是和树的高度成正比的，树的高度 h 是 log(n)，
但是最坏情况下以上操作的时间复杂度都是 O(n)。为了改善 BST 有很多变种，感兴趣请参考延伸阅读中的内容。</p>
<p><img alt="" src="../bst_worstcase.png" /></p>
<h1 id="_8">练习题：</h1>
<ul>
<li>请你实现查找 BST 最大值的函数</li>
</ul>
<h1 id="_9">延伸阅读</h1>
<ul>
<li>《Data Structures and Algorithms in Python》14 章，树的概念和算法还有很多，我们这里介绍最基本的帮你打个基础</li>
<li>了解红黑树。普通二叉查找树有个很大的问题就是难以保证树的平衡，极端情况下某些节点可能会非常深，导致查找复杂度大幅退化。而平衡二叉树就是为了解决这个问题。请搜索对应资料了解下。</li>
<li>了解 mysql 索引使用的 B-Tree 结构(多路平衡查找树)，这个是后端面试数据库的常考点。想想为什么？当元素非常多的时候，二叉树的深度会很深，导致多次磁盘查找。<a href="https://blog.csdn.net/v_JULY_v/article/details/6530142">从B树、B+树、B*树谈到R 树</a></li>
</ul>
<h1 id="leetcode">Leetcode</h1>
<p>验证是否是合法二叉搜索树 [validate-binary-search-tree](https://leetcode.com/problems/validate-binary-search-tree/</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../../18_图与图的遍历/graph/" class="btn btn-neutral float-right" title="18_图与图的遍历">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../../16_优先级队列/priority_queue/" class="btn btn-neutral" title="16_优先级队列"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../../16_优先级队列/priority_queue/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../../18_图与图的遍历/graph/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
      <script src="../../search/main.js" defer></script>

</body>
</html>
