{"title": "[微信小程序开发]如何去掉或隐藏小程序顶部栏navigationBar ", "author": "Rolan", "pub_time": "2018-7-30 00:12", "content": "小程序全局配置app.josn增加选项：\"navigationStyle\": \"custom\",具体如下：原生小程序开发打开 app.json：{    \"pages\": [        \"pages/index/index\",        \"pages/logs/index\"    ],    \"window\": {        \"backgroundTextStyle\": \"light\",        \"navigationBarBackgroundColor\": \"#000\",        \"navigationStyle\": \"custom\",        \"navigationBarTitleText\": \"WeChat\"    }}mpvue方式开发小程序>打开 /src/main.js：export default {  config: {    pages: [      'pages/logs/main',      '^pages/index/main'　　],    window: {      backgroundTextStyle: 'light',      navigationBarBackgroundColor: '#666',      navigationStyle: 'custom',      navigationBarTitleText: 'WeChat',      navigationBarTextStyle: '#fff',      enablePullDownRefresh: false,      disableScroll: true    }  }}"}
{"title": "微信小程序 - 前三排名实现 ", "author": "Rolan", "pub_time": "2018-7-27 00:09", "content": "实现原理：利用背景图片以及nth-child实现 作者：Sunsin原文：http://www.cnblogs.com/cisum/p/9370248.html"}
{"title": "微信小程序使用相机 ", "author": "Rolan", "pub_time": "2018-7-27 00:15", "content": "<view class=\"page-body\">  <view class=\"page-body-wrapper\">    <camera device-position=\"back\" flash=\"off\" binderror=\"error\" style=\"width: 100%; height: 300px;\"></camera>    <view class=\"btn-area\">      <button type=\"primary\" bindtap=\"takePhoto\">拍照</button>    </view>    <view class=\"btn-area\">      <button type=\"primary\" bindtap=\"startRecord\">开始录像</button>    </view>    <view class=\"btn-area\">      <button type=\"primary\" bindtap=\"stopRecord\">结束录像</button>    </view>    <view class=\"preview-tips\">预览</view>    <image wx:if=\"{{src}}\" mode=\"widthFix\" src=\"{{src}}\"></image>    <video wx:if=\"{{videoSrc}}\" class=\"video\" src=\"{{videoSrc}}\"></video>  </view></view>  onLoad() {    this.ctx = wx.createCameraContext()  },  takePhoto() {    this.ctx.takePhoto({      quality: 'high',      success: (res) => {        this.setData({          src: res.tempImagePath        })      }    })  },  startRecord() {    this.ctx.startRecord({      success: (res) => {        console.log('startRecord')      }    })  },  stopRecord() {    this.ctx.stopRecord({      success: (res) => {        this.setData({          src: res.tempThumbPath,          videoSrc: res.tempVideoPath        })      }    })  },  error(e) {    console.log(e.detail)  }/* pages/one/one.wxss */.preview-tips {  margin: 20rpx 0;  }.video {  margin: 50px auto;  width: 100%;  height: 300px;}"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:14", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "使用button标签的open-type=\"getUserInfo\"引导用户去授权 ", "author": "Rolan", "pub_time": "2018-5-23 00:24", "content": "一、 前言小程序官方文档，上面说明wx.getUserInfo(OBJECT) 注意：此接口有调整，使用该接口将不再出现授权弹窗，请使用引导用户主动进行授权操作 > 当用户未授权过，调用该接口将直接报错 当用户授权过，可以使用该接口获取用户信息如上文，之前用户未授权过时，调用wx.getUserInfo会调出授权框；但现在在用户未授权过时调用该接口，会直接走fail方法。所以我们要使用上述button来请求用户授权。二、主体以index页面作为展示授权按钮的页面，并且在app.json中将index作为首页。在判断用户授权之后跳转到其他页面。index.wxml<button    wx:if=\"{{canIUse}}\"    open-type=\"getUserInfo\"    bindgetuserinfo=\"bindGetUserInfo\">授权登录</button><view wx:else>请升级微信版本</view>index.js"}
{"title": "微信小程序 scroll-view滚动到底部事件不触犯的锅 ", "author": "Rolan", "pub_time": "2018-5-29 00:14", "content": "今日准备把微信小程序的下拉刷新做一下，没想到我绑定了bindscrolltolower事件，但是居然不触发,我设置了lower-threshold高度无济于事.最后经过不懈的努力，找了很多资料，才发现,居然要设置scroll-view高度，于是我在.wxss里设置了高度为100%:.scrollStyle{\r\n   width: 100%;\r\n   height: 100%; \r\n   display: flex;\r\n  flex-direction: column; \r\n}居然无效，修改height为具体高度也无效.然后我在 style里设置height为200px，居然生效了:<scroll-view style='height:{{scrollHeight}}px' class='scrollStyle' scroll-y='true' slot=\"0\" hidden=\"{{curindex != 0}}\" bindscrolltolower=\"loadMoreData\" lower-threshold=\"100\">注意:style里的height单位必须写px;scrollHeight怎么来的？是获取了屏幕高度,代码如下: let  scrollHeight = wx.getSystemInfoSync().windowHeight;\r\n    this.setData({\r\n      scrollHeight: scrollHeight\r\n    });scrollHeight其实是减去导航栏和tabbar的高度!ps:很啃爹只能写在style里才生效."}
{"title": "一个同时支持移动端与小程序的聊天机器人 ", "author": "Rolan", "pub_time": "2018-6-6 00:32", "content": "应公司需求，着手开发一个同时部署到移动端和微信小程序上产品需求相同的聊天机器人。于是初步构想：移动端使用Vue.js开发。小程序使用美团点评的开源框架mpvue复用移动端代码集成到小程序。一般来说，根据官方文档将两个端分开来写，重复代码直接复制粘贴基本上就可以实现公司的需求。但一天忽然心血来潮，想把两个项目合二为一，只在Power Shell里改变一条命令，就能构建出适应不同平台的项目，于是就有了这个东西。Git地址先贴为敬：Github聊天机器人接下来说一说为了实现这个骚想法所遇到的几个问题：一、如何通过一条命令来构建不同平台项目解决方法是把这个任务交给webpack来完成。webpack作为强大的前端模块化开发工具“用过都说好”，没用过的赶紧去用一下吧。小程序构建的webpack配置可以直接使用mpvue-cli的配置，里面用到了一些美团实现的vue文件转小程序文件的webpack插件，下载安装就可以了。移动端的webpack配置可以参考vue-cli的配置，熟悉webpack的话可以自己来写。当然也可以使用我的项目里的配置。构建不同项目时只需要使用npm命令启用不同的webpack配置文件就行。（手动修改项目package.json里的npm script）。遇到的第一个问题就这样愉快地解决了。二、http请求的封装以往Vue项目的http请求都是使用axios插件完成的，而小程序里的http请求必须调用微信的原生API——wx.request。因此为了同时支持两个平台，项目里需要将http请求封装并且能够自动识别调用。解决方法是使用vue的全局混入(mixins)方式。混入全局变量this.service通过判断是否是浏览器环境（if(window)），而指向不同的http模块。有了这种识别混入方式，基本上就可以通过将小程序的原生API在浏览器环境下重新全部实现一次而完成全部代码复用。三、页面跳转vue项目中使用vue-router跳转页面已经十分成熟了，但是mpvue的文档中却写明由于小程序页面的注册方式奇特而不支持vue-router的使用。但是有了上面的这种混入方式，还是可以实现曲线救国，在项目中引入vue-router。解决方法是全局混入this.router变量，同时封装小程序里的wx.navigateTo和web端的location.href方法实现页面跳转。四、页面间参数的传递web开发经常会通过在url上附带参数来传递，但小程序里是不允许这样的。解决方法是就去开心(wu nai)地去使用vuex吧，统一状态管理听起来就高大上~参阅文档上手vuex应该没什么问题，但vuex略微遗憾的是页面刷新会使状态参数丢失。为了使项目体验更佳我使用了vuex+localstorege的方式来存储参数（微信也原生实现了缓存数据的wx.setStorage）。这种方法两个端表现效果都还不错。五、其他1. 项目里尝试使用了 day.js 这个刚刚发布的时间处理库，轻量级，很不错。2. 百度的echarts插件移动端的表现很好，但最近发布的echarts for wx在小程序的表现有点差强人意。至此，一个同时支持移动端与小程序的聊天机器人技术层面基本实现，还有其它不足之处有待完善，github还会继续commits~转载请注明出处。附效果图："}
{"title": "利用css transition属性实现一个带动画显隐的微信小程序部件 ", "author": "Rolan", "pub_time": "2018-6-12 00:23", "content": "我们先来看效果图像这样的一个带过渡效果的小部件在我们实际开发中的应用几率还是比较大的，但是在开发微信小程序的过程中可能有的小伙伴发现transition这个属性它不好使（下面说明）所以我们这个时候会考虑去使用微信官方提供的wx.createAnimation API来创建动画。接下来我带各位小伙伴如何让 transition 属性在这种需求中好使起来，下面上代码page({\r\n    data: {\r\n        show:false//用于显示或隐藏控件\r\n    },\r\n    chanMask:function(){\r\n var isShow = this.data.show ? false : true;//如果显示就隐藏，隐藏就显示\r\n this.setData({\r\n            show:isShow\r\n        })\r\n    }\r\n})\r\n/*index.wxss*/\r\n/*显示前*/\r\n.mask-con{\r\ntransition: 1s; \r\nposition: fixed;\r\nwidth: 100%;\r\nheight: 300rpx;\r\nleft: 0;\r\nbottom: -300rpx;\r\n \r\ntext-align: center;\r\nline-height: 300rpx;\r\nbox-shadow: 0 1px 10px #aaa;\r\n}\r\n/*显示后*/\r\n.mask-con-show{\r\nbottom: 0;\r\n}\r\n<!--index.wxml-->\r\n<view class=\"container\">\r\n<button bindtap=\"chanMask\">点我</button>\r\n<view class=\"mask-con {{show ? 'mask-con-show' : ''}}\">\r\n<view class=\"close\" bindtap=\"chanMask\">X</view>\r\n慢慢飞起\r\n</view>\r\n</view>\r\n在以上代码中我们首先在data中定义了一个show变量用于mask-con控件的显示状态，在chanMask函数中交替的改变这个变量，然后将chanMask函数绑定给button和close控件的点击事件上，最后我们根据show来决定是否给mask-con（我们的动画控件）添加一个class： mask-con-show那么到这里我们已经实现了一个带过渡的显隐小部件，但是对于某些需求这还是太勉强了，比如下图的情况：现在很多的APP或小程序都是以这种方式来close弹窗控件，那个X用户点的不过瘾，看到这里聪明的小伙伴可能会想到再另外添加一个阴影控件在mask-con的下层并绑定上我们的chanMask函数，这样的话阴影控件和我们的mask-con就可能不是在一个整体上了，不够直观，又比如说领导要让这个阴影它有一个显示颜色慢慢加深，隐藏慢慢减淡的效果，为了应对这种情况，我们把代码调整如下：page({\r\n\r\n    data: {\r\n        show:false//用于显示或隐藏mask控件\r\n    },\r\n    chanMask:function(){\r\n var isShow = this.data.show ? false : true;//如果显示就隐藏，隐藏就显示\r\n this.setData({\r\n            show:isShow\r\n        })\r\n    }\r\n})\r\n/*index.wxss*/\r\n\r\n.mask-shadow{\r\nwidth: 100%;\r\nheight: 100%;\r\n \r\nopacity: 0;\r\ntransition: 1s;\r\n}\r\n.mask-shadow-on{\r\nopacity: 0.3;\r\n}\r\n.mask-con{\r\nposition: absolute;\r\nwidth: 100%;\r\nheight: 300rpx;\r\nleft: 0;\r\nbottom: -300rpx;\r\n \r\ntransition: 1s;\r\ntext-align: center;\r\nline-height: 300rpx;\r\nbox-shadow: 0 1px 10px #aaa;\r\n}\r\n.mask-con-show{\r\nbottom: 0;\r\n}\r\n<!--index.wxml-->\r\n<view class=\"container\">\r\n<button bindtap=\"chanMask\">点我</button>\r\n<view class=\"mask {{show ? 'show' : 'hide'}}\">\r\n<view class=\"mask-shadow {{show ? 'mask-shadow-on' : ''}}\"></view>\r\n<view class=\"mask-con {{show ? 'mask-con-show' : ''}}\">\r\n<view class=\"close\" bindtap=\"chanMask\">X</view>\r\n慢慢飞起\r\n</view>\r\n</view>\r\n</view>\r\n在这里我们设置了两个样式类名mask-shadow-on和mask-con-show来定义阴影以及主要控件mask-con动画后的效果（具体代码根据自己的需求决定），看起来一切都OK，没有任何问题，那么先运行一波，艾玛，神马情况？阴影和我们的mask-con直接怼了出来毫无过渡效果，那这是何原因影响我们程序的效果呢，经过一番考量博主发现在display为none的情况之下我们的transition属性可能会失效，那到这里有的小伙伴可能会问 “博主，那个不对啊，我们明明已经将mask的display设置成block怎么还有这种问题呢”是这样的，我们的mask控件它显示需要那么一点时间才能完全显示出来，但是呢我们的变量show设置成true之后，我们的阴影控件和主要控件也会马上添加上了动画后样式类名，这个时间它比mask显示所需的时间要快，所以我们的机器它认为mask还是处于display为none的情况打个比方说：mask是这一整块的老大，这个老大都还没表演完事，你们这些做小弟就已经出来抢风头了，你让当老大的面子往哪放，不行我得把你们这些抢我风头的都给干掉，看你们还得瑟。这个老大的人狠话不多，你抢了他风头不行，你想不表演他（用户体验）也不高兴，而且他表演完了还不跟你说，那这个老大这么难伺候该怎么办呢？有的小伙伴已经感觉到迷茫了吗，那还在等什么，赶快拿起你手中的电话拨打求助热线。。。。。啊呸，扯远了其实决解的方法很简单，没错答案就是 setTimeout()函数，来，我们把代码再改一遍：page({\r\n        data: {\r\n        show:false,//用于显示或隐藏mask控件\r\n        runAM:false//用于动画执行的根据\r\n    },\r\n    chanMask:function(){\r\n var isShow = this.data.show ? false : true;//如果显示就隐藏，隐藏就显示\r\n var delay  = isShow ? 30 : 1000;//第一个时间是博主测出来控件显示所需的时间，第二个是动画所需的时间\r\n if(isShow){\r\n this.setData({\r\n                show:isShow\r\n            });\r\n        }else{\r\n this.setData({\r\n                runAM:isShow\r\n            })\r\n        }\r\n \r\n        setTimeout(function(){\r\n if(isShow){\r\n this.setData({\r\n                    runAM:isShow\r\n                });\r\n            }else{\r\n this.setData({\r\n                    show:isShow\r\n                });\r\n            }\r\n        }, delay);\r\n\r\n    }\r\n})\r\n<!--index.wxml-->\r\n<view class=\"container\">\r\n<button bindtap=\"chanMask\">点我</button>\r\n<view class=\"mask {{show ? 'show' : 'hide'}}\" bindtap=\"chanMask\">\r\n<view class=\"mask-shadow {{runAM ? 'mask-shadow-on' : ''}}\"></view>\r\n<view class=\"mask-con {{runAM ? 'mask-con-show' : ''}}\">\r\n<view class=\"close\" bindtap=\"chanMask\">X</view>\r\n慢慢飞起\r\n</view>\r\n</view>\r\n</view>\r\n在以上代码中，我们给data新添加了一个变量runAM用于动画何时开始执行的凭证，再在chanMask函数定义了一个用于设置延时的变量delay 代码可能有点绕博主在此粗暴的解释一下程序的整个过程都是根据isShow这个变量来走的，当isShow为true时也就是说我们要打开mask控件了，所以我们先把mask控件显示出来，然后在延时30毫秒后去为要执行动画的控件添加上样式类名当isShow为false时我们先把动画控件的类名去掉（去掉后会执行动画回到原本的形态），然后在延时1000毫秒（动画所需的时间）后让mask隐藏关于delay的第一个值的设定时博主自己测出来的，如果各位小伙伴还担心控件没显示的话可以设成50毫秒或100毫秒都无所这0.1秒的时间差对用户体验的影响并不大，如过你设了1秒都没反应，我只能说换手机吧最后你会发现在整个过程中博主都只调用一个函数进行显示或隐藏，并没有为关闭新建函数处理，这种写法逼格满满有木有此方法同样适用于H5新人第一次写博客有点啰嗦了，望见谅GitHub连接 https://github.com/1441327053/frontEnd-WXapp/tree/master/widget-transition"}
{"title": "世界杯来了！小程序赛事操作来一波~ ", "author": "Rolan", "pub_time": "2018-6-20 14:16", "content": "NBA总决赛结束还没一周，马上世界杯就如期而至。大家在熬夜看球，而我关在小黑屋默默码字（可怜脸）。在体验到小程序的 方便快捷省内存 之后，前段时间的“骑勇大战”果断用了小程序观看。由于体验不错，又正在学习小程序知识，马上就想动手实践学习一下“腾讯体育”小程序的制作。到目前为止，只想说一句“选择是好的，过程是一言难尽的”，虽然还没全部完成，但也遇到不少问题，希望此分享可以给你带来帮助。效果图（干巴巴的开讲，还不如先来波动图）问题及解决方案1、scroll-view组件让我们先来看看开发文档scroll-x在此项目中，首页——世界杯的头部是一个横向滑动的 scroll-view 组件，在设置了 scroll-x 属性后，并未达到预期效果，scroll-view中的每个部分还是自成一行。在一番简单搜索后得出，设置 white-space: nowrap; 样式就可使其在同一行。scroll-yNBA赛事详情页中有5个sroll-view，虽然内容有点少，但还是看得出有scroll的效果的。同样的，在制作竖向滚动效果时，需要设置 sroll-y 属性，在官方的文档中也特别说明了使用竖向滚动时，需要给 scroll-view 一个固定高度，通过 WXSS 设置 height。那么问题来了，在 scroll-view 并非占满全屏的情况下，如何确定其高度呢？首先想到，把包含选项卡和 scroll-view 的大盒子固定宽度后，在遵循文档流的情况下，将 scroll-view 高度设置为 100%不就好了吗？但是，在如此一番设置之后， scroll-view 的高度变成了大盒子的高度？？？（黑人问号脸），最重要的是 scroll-view 中的内容不能完全显示，这就头疼了。随后马上想到可以使用弹性布局，固定其选项卡的高度，下方的 scroll-view 设置 flex: 1，这难道还解决不了吗？是的，bug永相随。下图可以看到，选项卡的高度明显变小，要是scroll-view的内容再多一点，选项卡就被挤到窒息了。最后无奈只好将scroll-view的高度逐渐调整到屏幕底部的高度，简直不要太粗暴，缺点是在不同屏幕尺寸设备上查看，效果不一。如果有大佬可提供较好解决方案，恳请指教。2、swiper组件开发文档是好朋友，让我们再来看看。swiper 组件在小程序中非常常见，它可在有限的区域展示更多内容，还能增加页面的视觉动态效果，总之就是好。（但，好东西也是有槽点的啦）1） 从上面动图可看出，NBA赛事详情页中也使用到了 swiper 组件，并且与头部的导航进行了绑定，滑动 swiper 可改变导航栏的状态，点击导航栏选项可切换 swiper-item 。这个实现较为简单，步骤如下：在 data 中添加一个表示下标的变量 curIndex ；将此变量绑定到导航栏各个选项，同时使用一个三目运算符进行 wx:if 条件渲染，若 curIndex 等于当前选项的下标，则在其底部添加一个伪元素表示选中；将 curIndex 绑定到 swiper 的 current 属性中，通过选项卡的 bindtap 事件和 swiper的 bindchange 事件实时切换 swiper-item 。话不多说，贴上代码：//nbaMatches.wxml\r\n<view class=\"info_hd\">\r\n    <view class=\"headerMenu {{curIndex===index?'on':''}}\" \r\n        wx:for=\"{{nbaMenu}}\"\r\n        data-index=\"{{index}}\" \r\n        bindtap=\"switchSort\">\r\n        <view class=\"nbaSort\">{{item.nbaSort}}</view>\r\n    </view>\r\n</view>\r\n<view class=\"info_bd\">\r\n    <swiper current=\"{{curIndex}}\" bindchange=\"bindswiper\">\r\n        ...\r\n    </swiper>\r\n</view>//nbaMatches.js\r\nbindswiper(e) {\r\n    this.setData({\r\n      curIndex: e.detail.current\r\n    })\r\n  },\r\nswitchSort(e) {\r\n    console.log(e.currentTarget.dataset.index);\r\n    this.setData({\r\n      curIndex: e.currentTarget.dataset.index?e.currentTarget.dataset.index: 0\r\n    })\r\n}2） 此项目的“热门”页也使用了一个 swiper 组件，相比普通 swiper 的使用，这个更为复杂。此处的 swiper 不再是与有限个的选项进行交互，而是与无限个的日期进行交互。难道一年365天就要365个 swiper-item ？ 吓得老夫虎躯一震。经过一场“猪脑子”风暴后，还是没有想出完美的解决方案，只好设置有限个 swiper-item 来初步实现所需效果。还是贴代码吧！//swiper的bindchange事件\r\nchangeMatch(e) {\r\n    const current = e.detail.current;   //获取当前位置\r\n    const befInd = this.data.swiperCurIndex;  //获取滑动前的位置\r\n    const index = current - befInd;\r\n    if (index <= -1) {   //判断左滑右滑\r\n      this.preDay();   //日期切换至前一天\r\n    } else if (index >= 1) {\r\n      this.nextDay();   //日期切换至后一天\r\n    } else {\r\n      return\r\n    }\r\n  }// nextDay() 方法类似\r\npreDay() {\r\n    let day = this.data.day;\r\n    let month = this.data.month;\r\n    let week= this.data.week;\r\n    let i = this.data.i;\r\n    if (i<=0) {  //周一至周日的循环切换\r\n      i = 6;\r\n    }else {\r\n      i--;\r\n    }\r\n    if(day<=1) {  //日期本月第一天时，将日期切换至上月最后一天\r\n      month--;\r\n      day = this.data.daysCountArr[month-1];\r\n    }else {\r\n      day--;  //否则切换至前一天\r\n    }\r\n    this.setData({\r\n      swiperCurIndex: this.data.swiperCurIndex-1,\r\n      month,\r\n      day,\r\n      i,\r\n      week: this.data.weekArr[i],\r\n      curDate: month+'月'+day+'日'+' '+this.data.weekArr[i]\r\n    })\r\n  }如果大佬们有解决方案欢迎交流讨论。详细代码查看可点击 这里 。3、选项卡天啦噜！你连选项卡都要说？（笑哭）听我解释。通常我们使用的选项卡中的选项都是 2 到 4 个，如果不嫌麻烦，我们只要将选项卡和其对应的内容逐个在 .wxml 中写出来就好了。但是，一旦选项变多，若逐个写出，那 .wxml 中的代码将跟“懒婆娘的裹脚布”似的。此时，使用 wx:for 来循环输出选项就非常有必要了。另外，如果每个选项中的内容都是类似的就更好了，可通过选项卡的点击事件获得当前选项的 id ，根据 id 使用 wx:if 条件渲染来决定当前选项卡显示的数据。在这又要cue一下我们的 NBA赛事详情页 ，此页面中的球员榜这个 swiper-item 就包含了一个有 5 个选项的选项卡。详细代码查看可点击 这里 。4、自定义日历为了更好的体验，体育赛事总要加入日历，方便用户查看赛事安排。若使用 picker 组件，用户体验可能差强人意，那么如何自定义一个日历呢？在参照了各路大神的方法后得出以下分析：可左右切换月份并显示当月日历。腾讯体育官方小程序的日历可左右滑动切换，与“热门”页类似。由于还没有解决方案，在这里没有使用 swiper 组件。日历主体中的每月日期是一个二维数组，每月的周数则为数组的length，因此wxml中的日期输出需要使用两重 wx:for 。部分代码如下：<view class=\"calendar_box\" wx:for=\"{{dateList}}\"  wx:for-item=\"week\" wx:key=\"{{index}}\" style=\"{{index==0?'justify-content: flex-end;':''}}\">\r\n    <view wx:for=\"{{week}}\" data-date=\"{{item}}\" \r\n        class=\"weekday_label {{item.value==selectedDate?'active_label':''}}\" bindtap=\"selectDate\">\r\n        <view class=\"date\">\r\n            <text>{{item.date}}</text>  \r\n        </view>\r\n        <view class=\"gameNumBox\">\r\n            <text class=\"gameNum\">{{item.gameNum}}</text>\r\n            <text>场比赛</text>\r\n        </view> \r\n    </view>\r\n</view>默认高亮显示当天日期，点击具体日期高亮显示。这个实现起来较为简单，只需得到通过点击事件获取当前点击日期，在 .wxml 中使用三目运算符判断获取日期与数据中的日期是否相同，从而达到高亮显示的效果。返回今天。点击“返回今天”可回退至“热门”页并显示当天的赛事。使用小程序自带 API —— wx.navigateBack(OBJECT) 即可返回上一页面，以下为文档截图：值得注意的是：wx.navigateTo 和 wx.redirectTo 不允许跳转到 tabbar 页面，只能用 wx.switchTab 跳转到 tabbar 页面"}
{"title": "微信小程序-封装请求（GET、POST） ", "author": "Rolan", "pub_time": "2018-6-27 00:18", "content": "使用：先导入到util.js  最后在页面上导入util.js（路径自改）var util = require('../../util.js'); 使用示例GET：util.SEND(url,'GET',res=>,res=>);使用示例POST：util.SEND(url,'POST',res=>,res=>); 使用实例：   源码： 1 function SEND(url, method, data, success, fail) {\r\n 2   wx.request({\r\n 3     url: url,\r\n 4     header: {\r\n 5       'content-type': 'application/json',\r\n 6     },\r\n 7     method: method,\r\n 8     data: data,\r\n 9     success(res) {\r\n10       success(res);\r\n11     },\r\n12     fail(res) {\r\n13       fail(res);\r\n14     }\r\n15   });\r\n16 }"}
{"title": "微信小程序使用code换openid的方法（JAVA、SpringBoot） ", "author": "Rolan", "pub_time": "2018-7-2 00:32", "content": "微信小程序序的代码中提示，使用code换取openid，但官方文档中没有给出进一步的说明。换取openid的要点：由于安全的原因，必须由自己小程序的服务器端完成。知道了这个要点，实现起来就简单了，服务器端写一个RestController，接收code参数，使用httpclient向微信的服务端换openid就行了。代码使用了SpringBoot，不会也不难理解。主要代码如下：package com.wallimn.iteye.sp.asset.common.controller;\r\n\r\nimport java.util.Map;\r\n\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.web.bind.annotation.RequestBody;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RequestMethod;\r\nimport org.springframework.web.bind.annotation.RequestParam;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.wallimn.iteye.sp.asset.common.util.AesUtil;\r\nimport com.wallimn.iteye.sp.asset.common.util.HttpUtil;\r\n\r\n@RestController\r\n@RequestMapping(\"/api/wx\")\r\npublic class WeixinController {\r\n\r\n\tprivate static Logger log = LoggerFactory.getLogger(WeixinController.class);\r\n\r\n\t@Value(\"${wx.appId}\")\r\n\tprivate String appId;\r\n\r\n\t@Value(\"${wx.appSecret}\")\r\n\tprivate String appSecret;\r\n\r\n\t@Value(\"${wx.grantType}\")\r\n\tprivate String grantType;\r\n\t// wx.grantType=authorization_code\r\n\r\n\t@Value(\"${wx.requestUrl}\")\r\n\tprivate String requestUrl;\r\n\t// wx.requestUrl=https://api.weixin.qq.com/sns/jscode2session\r\n\r\n\t@RequestMapping(\"/session\")\r\n\tpublic Map<String, Object> getSession(@RequestParam(required = true) String code) {\r\n\t\treturn this.getSessionByCode(code);\r\n\t}\r\n\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tprivate Map<String, Object> getSessionByCode(String code) {\r\n\t\tString url = this.requestUrl + \"?appid=\" + appId + \"&secret=\" + appSecret + \"&js_code=\" + code + \"&grant_type=\"\r\n\t\t\t\t+ grantType;\r\n\t\t// 发送请求\r\n\t\tString data = HttpUtil.get(url);\r\n\t\tlog.debug(\"请求地址：{}\", url);\r\n\t\tlog.debug(\"请求结果：{}\", data);\r\n\t\tObjectMapper mapper = new ObjectMapper();\r\n\t\tMap<String, Object> json = null;\r\n\t\ttry {\r\n\t\t\tjson = mapper.readValue(data, Map.class);\r\n\t\t} catch (Exception e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\t// 形如{\"session_key\":\"6w7Br3JsRQzBiGZwvlZAiA==\",\"openid\":\"oQO565cXXXXXEvc4Q_YChUE8PqB60Y\"}的字符串\r\n\t\treturn json;\r\n\t}\r\n}用到了一个httpclient封闭的工具类，代码如下：package com.wallimn.iteye.sp.asset.common.util;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.net.URI;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\nimport org.apache.http.HttpResponse;\r\nimport org.apache.http.NameValuePair;\r\nimport org.apache.http.client.HttpClient;\r\nimport org.apache.http.client.entity.UrlEncodedFormEntity;\r\nimport org.apache.http.client.methods.HttpGet;\r\nimport org.apache.http.client.methods.HttpPost;\r\nimport org.apache.http.entity.StringEntity;\r\nimport org.apache.http.impl.client.HttpClientBuilder;\r\nimport org.apache.http.message.BasicNameValuePair;\r\n\r\npublic class HttpUtil {\r\n\r\n\tprivate static final String Charset = \"utf-8\";\r\n\r\n\r\n\t/**\r\n\t * 发送请求，如果失败，会返回null\r\n\t * @param url\r\n\t * @param map\r\n\t * @return\r\n\t */\r\n\tpublic static String post(String url, Map<String, String> map) {\r\n\t\t// 处理请求地址\r\n\t\ttry {\r\n\t\t\tHttpClient client = HttpClientBuilder.create().build();\r\n\t\t\tURI uri = new URI(url);\r\n\t\t\tHttpPost post = new HttpPost(uri);\r\n\r\n\t\t\t// 添加参数\r\n\t\t\tList<NameValuePair> params = new ArrayList<NameValuePair>();\r\n\t\t\tfor (String str : map.keySet()) {\r\n\t\t\t\tparams.add(new BasicNameValuePair(str, map.get(str)));\r\n\t\t\t}\r\n\t\t\tpost.setEntity(new UrlEncodedFormEntity(params, Charset));\r\n\t\t\t// 执行请求\r\n\t\t\tHttpResponse response = client.execute(post);\r\n\r\n\t\t\tif (response.getStatusLine().getStatusCode() == 200) {\r\n\t\t\t\t// 处理请求结果\r\n\t\t\t\tStringBuffer buffer = new StringBuffer();\r\n\t\t\t\tInputStream in = null;\r\n\t\t\t\ttry {\r\n\t\t\t\t\tin = response.getEntity().getContent();\r\n\t\t\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(in,Charset));\r\n\t\t\t\t\tString line = null;\r\n\t\t\t\t\twhile ((line = reader.readLine()) != null) {\r\n\t\t\t\t\t\tbuffer.append(line);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t} finally {\r\n\t\t\t\t\t// 关闭流\r\n\t\t\t\t\tif (in != null)\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tin.close();\r\n\t\t\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn buffer.toString();\r\n\t\t\t} else {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t} catch (Exception e1) {\r\n\t\t\te1.printStackTrace();\r\n\t\t}\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * 发送请求，如果失败会返回null\r\n\t * @param url\r\n\t * @param str\r\n\t * @return\r\n\t */\r\n\tpublic static String post(String url, String str) {\r\n\t\t// 处理请求地址\r\n\t\ttry {\r\n\t\t\tHttpClient client = HttpClientBuilder.create().build();\r\n\t\t\tURI uri = new URI(url);\r\n\t\t\tHttpPost post = new HttpPost(uri);\r\n\t\t\tpost.setEntity(new StringEntity(str, Charset));\r\n\t\t\t// 执行请求\r\n\t\t\tHttpResponse response = client.execute(post);\r\n\r\n\t\t\tif (response.getStatusLine().getStatusCode() == 200) {\r\n\t\t\t\t// 处理请求结果\r\n\t\t\t\tStringBuffer buffer = new StringBuffer();\r\n\t\t\t\tInputStream in = null;\r\n\t\t\t\ttry {\r\n\t\t\t\t\tin = response.getEntity().getContent();\r\n\t\t\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(in,\"utf-8\"));\r\n\t\t\t\t\tString line = null;\r\n\t\t\t\t\twhile ((line = reader.readLine()) != null) {\r\n\t\t\t\t\t\tbuffer.append(line);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} finally {\r\n\t\t\t\t\t// 关闭流\r\n\t\t\t\t\tif (in != null)\r\n\t\t\t\t\t\tin.close();\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn buffer.toString();\r\n\t\t\t} else {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * 发送GET方式的请求，并返回结果字符串。\r\n\t * <br>\r\n\t * 时间：2017年2月27日，作者：http://wallimn.iteye.com\r\n\t * @param url\r\n\t * @return 如果失败，返回为null\r\n\t */\r\n\tpublic static String get(String url) {\r\n\t\ttry {\r\n\t\t\tHttpClient client = HttpClientBuilder.create().build();\r\n\t\t\tURI uri = new URI(url);\r\n\t\t\tHttpGet get = new HttpGet(uri);\r\n\t\t\tHttpResponse response = client.execute(get);\r\n\t\t\tif (response.getStatusLine().getStatusCode() == 200) {\r\n\t\t\t\tStringBuffer buffer = new StringBuffer();\r\n\t\t\t\tInputStream in = null;\r\n\t\t\t\ttry {\r\n\t\t\t\t\tin = response.getEntity().getContent();\r\n\t\t\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(in,Charset));\r\n\t\t\t\t\tString line = null;\r\n\t\t\t\t\twhile ((line = reader.readLine()) != null) {\r\n\t\t\t\t\t\tbuffer.append(line);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} finally {\r\n\t\t\t\t\tif (in != null)\r\n\t\t\t\t\t\tin.close();\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn buffer.toString();\r\n\t\t\t} else {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\treturn null;\r\n\r\n\t}\r\n}小程序中，使用wx.request(url:'https://域名/api/wx/session',....)，就可以拿到一个JSON对象，其中有openid。"}
{"title": "2个方面总结：小程序的产品设计 ", "author": "Rolan", "pub_time": "2018-7-9 00:01", "content": "每个人都有自己的方法，来分析需求，了解市场情况，探索用户价值，只是在探索的过程中有没有扣中需求的本质。小程序的点比较特殊 ，因为在移动互联网的流量如此之贵的情况下 ，突然能够拥抱微信10个亿的月活用户数，至少对于电商和游戏都乐开怀了，电商本质是订单，所以他才不管你在哪个平台上面，而游戏的道具付费也是一样的道理 。小程序几个最核心的要点：微信社交关系链，这是最核心的价值，你玩游戏 ，你会想让好友家人知道你有多利害，所以比APP更容易去让周围的人参与进来，这个流程可以促发更多的可能。小程序不需要安装，即点即用，用完即走：一是用户使用没有心里负担；二是省了 APP下载的漏斗转化的核心问题，要知道一个从广告展示到下载安装激活的漏斗路径，很多时候是惨不忍赌的，而且后面还有一堆在刷机的产业链。一开始的流量足够便宜，让很多小团队可以发挥出来余地，所以这就是时间窗口期的问题  ，流量只会越来越贵，大厂陆陆续续都进来了，只会把整个流量市场炒得越来越高。所以小程序要解决2大问题：是用户为什么打开？是用户为什么要分享？两件事情能够很好的想清楚， 这就相对比较好去撸产品了， 所以我们称之为「场景化设计 」，前几个给赞大哥有分享过相关的内容 ，就不具体展开了。一、用户为什么点开？这个就是需求设计的一个最本质的点，有很多的形式让用户点开，网上会有很多关于描述色情、暴力、美食、隐私、名人、偷窥欲什么的让用户点开的可能。但是这个并不是我们要讨论的东西，而是回到本质问题，就是用户care什么，就是在他们当下所处的环境下，我们解决了他们什么问题 ，提供了什么价值给他们。我简单从2个点来切好了：1.1 哪个领域是人类社会活动最频繁的？第一个就是去看数据，哪些数据是人类最频繁的行为，他们有什么特点。围绕着人类历史，永远离不开食色性也，还有吃喝玩乐，这一块永远是巨大的市场，还有人们生活中日常关注最多的教育问题、养老问题、工作问题、生育问题。我们要解决的问题找到领域本身，问问自己新的产品还能不能再节省成本？能不能提高效率？还能不能满足用户的情感诉求？关于如何找，可以利用好搜索引擎，需求往往藏在搜索引擎里。找关键词，找到相关的问题，找到近义词，类似相同的场景，然后人们一般怎么解决这些问题的，其实搜索引擎基本上可以把大概的东西简单摸了个底。anyway，用搜索和数据来了解场景，哪些是人们care的，哪些又是用户基本上不care的，再一一过滤。尊重数据是一件很难的事情，人是有很强的主观意识的，还有不少人会觉得他要创新，就是要与众不同。其实很多时间只是你的一厢情愿，或者是个人喜好，这就是搜索引擎的价值，数据的价值，需求就在那里，而不是拍脑袋做决定 ，或者是意淫。1.2 关于用户切身相关的一些日常心理属性有哪些？这个就是人们日常生活的一些基本的心理需求，人们需要社交，需要新鲜感，天然对萌的东西无有抵抗力。人们会有偷窥欲，会喜欢色情、暴力、美食、游戏、无聊，想表达自己与众不同或者什么的，或者会念旧什么，whatever，就也是需求所有。曾经APP火过的玩法，在微信小程序依然会引爆，而且可能更快，因为那是被证实过的事实，我们要尊重事实。只是都挺难展开说明的，只能说去琢磨好了，越俗的东西则越说明人的共性，只是共性后面的本质是什么，仁者见仁，智者见智了。二、用户为什么自己转发？传播的2个基本要点：情感需求和利益诱导。从用户情感需求相关的东西炫耀、装逼、搞笑，他很容易就会转发，比如：P了自己的美照，玩了自己感兴趣的游戏达到新成就，用户发自内心可以激起身体多巴胺的分泌，那你引导他分享的价值就很大了，因为容易形成话题的可能。从利益诱导出发，让利、免费、便宜，我给你目标引导用户去完成。游戏规则 「拼多多」你必须完成3个邀请才让你拼团什么的，这个更多是对人性和对任务完成难易度的把握。好了，扯了这么多，就到具体的产品设计上了。几个问题一定要自己想清楚了，就是关于用户选择新产品的问题 ：为什么用户要选择它？为什么用户会喜欢它？为什么它比传统的方式更好？用户不会平白无故的用上你的产品，要么你有大厂做靠山，产品只是最初的一个环节，如何运营整个产品才是核心所在，功能只是一小部分。用户怎么接触到这个产品，凭什么会选择它？为什么他要选择放弃原来用得好好的产品，需要你给他价值，所以价值是什么？多琢磨一下。接下来就是关于产品的设计的几个要点， 这个是从贝佐斯分享过的产品方法，只是我在具体的产品设计中把它当成checklist在使用。谁在使用这个产品？新产品会带来什么价值？它创作价值的方式是怎样的？为什么要开发这个产品？就是要明确你的目标用户群体是谁，他们有什么特点，他们有什么需求，是否有付费的意愿和可能？然后，产品创作价值的方式是怎么样的 ？用户如何使用你的产品？用户的需求或痛点如何得到满足？最后再返过来问一下自己，为什么要开发这个产品？想清楚了就可以再最后总结一下，利用李想的产品的方法；产品提供了什么价值 ？产品对用户有什么优越感？产品是否要考虑用户安全感？衡量用户价值就二个点「时间和金钱」，用户愿意花时间在你的产品上才有价值，或者用户愿意花钱在你的产品上面。优越感会变成你的品牌向外传播的口碑，安全感决定了用户是不是用你或买你。我们的产品探索中，在团队也是讲究我们要解决的问题设定一个目标，这个目标必须清晰、可衡量和我们做产品时只谈价值，不谈用户体验，当然这都很难去实践。好了，首次分享，就到这里，请大佬点评。 本文由 @搞趣阿达 原创发布于人人都是产品经理。未经许可，禁止转载题图来自网络"}
{"title": "微信小游戏好友排行榜快速开发教程 ", "author": "Rolan", "pub_time": "2018-7-19 00:58", "content": "要做这个好友排行榜.必然要有好友的战绩比分,然后再做排序,最后将数据呈现在UI上 , 可以分为下面几个步骤:保存每个用户的分数获取好友列表,并获取好友的分数渲染排行榜保存每个用户的分数保存每个用户的分数,需要调用微信的云存储API,将用户的分数持久化的存起来 .// 保存用户数据,注意限制单条数据容量不得超过1024字节,\r\n// 单个用户数据总条数不得超过128条\r\nwx.setUserCloudStroage(Object)复制代码//存储最高分\r\nvar score = 100;\r\nvar kvScore = {\"key\":\"score\",\"value\":score};\r\nwx.setUserCloudStroage({\"KVDataList\":[kvScore]},\"success\":function(){\r\n    //\r\n});复制代码获取好友列表,并获取好友的分数​ 游戏中将玩家的分数保存起来以后,需要调用微信的云存储API wx.getFirendCloudStorage, 获取玩家的微信好友数据,这样就拿到了每个好友的最高分.值得一提的是,微信的这个接口在内部隐蔽的使用其微信的社交关系链 .返回列表中的包含的 调用过wx.setUserCloudStroage 这个接口的用户.渲染排行榜对分数进行排序 , 得到一个排行榜let sharedCanvas = wx.getSharedCanvas()\r\n\r\nfunction drawRankList (data) {\r\n  data.forEach((item, index) => {\r\n    // ...\r\n  })\r\n}\r\n\r\nwx.getFriendCloudStorage({\r\n  success: res => {\r\n    let data = res.data\r\n    drawRankList(data)\r\n  }\r\n})复制代码注意这个 sharedCanvas , 这是独有的画布 ,与小游戏中的画布不是同一个东东.使用sharedCanvas来自定义显示玩家的用户排行榜重要说明​ 上述所涉及的微信接口 , 都只能在微信小游戏的 子域 使用 , 微信官网也称之为开放数据域 , 其实应该称之为 封闭数据域 . ​ 为什么这么说呢?​ 因为子域的js代码执行环境和小游戏本身的代码执行环境是隔离的. 两者之间不能相通 , 子域只能接收外部的消息(如游戏的最高分),不能往外发消息(不能把用户的好友关系链数据发给开发者服务器) , 内存不共享,也就意味着,开发者拿不到微信的社交关系链数据 . 在这样的封闭条件下,开发者能做的只能是在子域的画布上将排行榜数据以个性化的UI元素展示出来 。"}
{"title": "小程序开发技巧总结 ", "author": "Rolan", "pub_time": "2018-7-20 00:25", "content": "最近公司要开发一款电商小程序，匆忙看了一遍文档就开始干活了。整体开发体验个人感觉不太好，特别是如果之前习惯了Vue开发，突然去开发小程序，感觉很鸡肋。以下是我在开发中遇到的一些问题以及解决方法的总结，仅供参考引入iconfont在小程序中引入字体图标要比web麻烦一些，简单说需要三步：下载iconfont，把iconfont.css复制到iconfont.wxss，在app.wxss中引入查看iconfont在unicode模式下的在线链接，替换iconfont.wxss中的链接为远程链接在wxml文件中引入对应的icon class<icon class=\"iconfont icon-pay\"></icon>\r\n复制代码使用lessvscode有一个easy less插件，是我感觉使用less最简单的方式vscode安装easy less插件创建一个less目录，用于存放less文件文件头部添加编译注释 // out: ../pages/index/index.wxss, compress: true, sourceMap: falsectrl + s保存后自动编译编译后的结果按钮重置小程序中的按钮功能强大，很多功能必须要用按钮，比如弹出用户授权，调用客服功能。默认的样式一般无法满足需求，可以把按钮样式统一重置，然后自己写样式button {\r\n  padding: 0;\r\n  background: #fff;\r\n  line-height: 0;\r\n  &::after {\r\n    border-color: transparent;\r\n  }\r\n}\r\n.button-hover {\r\n  background: #fff;\r\n}\r\n复制代码支持async-awaitasync-await是ES7的语法，截止我写这篇文章为止，小程序还是不支持async-await语法的，所以需要使用regenerator这个库下载regenerator，并把regenerator-runtime并放到utils目录下2. 在util.js引入 import regeneratorRuntime from './regenerator-runtime/runtime-module'封装wxRequest，让它支持async-awaitconst wxRequest = async (url, params = {}) => {\r\n  Object.assign(params, {\r\n    token: wx.getStorageSync('token')\r\n  })\r\n  // 所有的请求，header默认携带token\r\n  let header = params.header || {\r\n    'Content-Type': 'application/json',\r\n    'token': params.token || ''\r\n  }\r\n  let data = params.data || {}\r\n  let method = params.method || 'GET'\r\n  // hideLoading可以控制是否显示加载状态\r\n  if (!params.hideLoading) {\r\n   wx.showLoading({\r\n     title: '加载中...',\r\n   })\r\n  }\r\n  let res = await new Promise((resolve, reject) => {\r\n    wx.request({\r\n      url: url,\r\n      method: method,\r\n      data: data,\r\n      header: header,\r\n      success: (res) => {\r\n        if (res && res.statusCode == 200) {\r\n          resolve(res.data)\r\n        } else {\r\n          reject(res)\r\n        }\r\n      },\r\n      fail: (err) => {\r\n        reject(err)\r\n      },\r\n      complete: (e) => {\r\n        wx.hideLoading()\r\n      }\r\n    })\r\n  })\r\n  return res\r\n}\r\n\r\nexport {\r\n  wxRequest\r\n}\r\n复制代码使用方法：import regeneratorRuntime from '../../utils/regenerator-runtime/runtime-module.js'\r\nimport {\r\n  wxRequest\r\n} from '../../utils/util.js'\r\n\r\nPage({\r\n  data: {\r\n   list:[],\r\n   count: 0,\r\n   page: 1,\r\n   limit: 10\r\n  },\r\n  onLoad: function() {\r\n    this.getList()\r\n    // 请求已经结束 做其他事\r\n  },\r\n  getList: async function() {\r\n    await wxRequest(app.globalData.baseUrl + '/test',{\r\n      hideLoading: true,\r\n      data: {\r\n        limit: this.data.limit,\r\n        page: this.data.page\r\n      }\r\n    }).then((ret) => {\r\n      this.setData({\r\n        list: ret.data.data,\r\n        count: ret.data.num\r\n      })\r\n    })\r\n  }\r\n})\r\n复制代码封装之后用起来还是很爽的，扩展起来也方便动态设置data中某个值应用场景：循环出来的列表，需要根据点击项，动态改变列表中对应id的数据// 动态传递id\r\n<block wx:for=\"{{list}}\" wx:key=\"{{index}}\">\r\n  <view catch:tap=\"onChangeName\" data-id=\"{{item.id}}\"></view>\r\n</block>\r\n\r\nPage({\r\n  data: {\r\n    list:[{\r\n      id: 0,\r\n      name: 'wang'\r\n    },{\r\n      id: 1,\r\n      name: 'li'\r\n    }]\r\n  },\r\n  onChangeName: function(event){\r\n    // 拿到id\r\n   let id = event.target.dataset.id\r\n   let key = `list[${id}].name`, val = 'zhang'\r\n   // 设置值\r\n   this.setData({\r\n    [key]: val\r\n   })\r\n  }\r\n})\r\n复制代码flex布局，溢出省略号无效订单列表一般都是左边一个图片，右边是标题或描述。这时候图片宽度是固定的，标题长度自适应.wrap {\r\n  display: flex;\r\n}\r\n.sub {\r\n  flex: 1;\r\n  width: 0; // 宽度设为0\r\n}\r\n.sub text {\r\n  display: block; // 一定要设置成block\r\n}\r\n\r\n<view calss=\"wrap\">\r\n  <image src=\"i.png\"/>\r\n  <view class=\"sub\">\r\n    <text>一段文本一段文本一段文本一段文本一段文本一段文本</text>\r\n    <view>其他</view>\r\n  </view>\r\n</view>\r\n复制代码组件事件传递任务：父组件向子组件传递初始数据，当子组件点击以后可以triggerEvent自定义事件，父组件执行自定义事件，重新请求数据并传给子组件/* 子组件 */\r\n<view>\r\n  <view bind:tap=\"setId\" data-id=\"1\"></view>\r\n</view>\r\n\r\nproperties: {\r\n  list: {\r\n    type: Array,\r\n    default: []\r\n  }\r\n},\r\n\r\nmethods: {\r\n  setId(e) {\r\n    let id = e.currentTarget.dataset.id\r\n    this.triggerEvent('deleteFav', id)\r\n  }\r\n}\r\n\r\n/* 父页面 */\r\n<child bind:customEvent=\"deleteFav\"></child>\r\n\r\ndata: {\r\n  list: []\r\n},\r\ndeleteFav(e) {\r\n  let id = e.detail // 获取传递过来的数据\r\n  // 根据id请求数据，然后重新setData\r\n  let newData = [1,2,3]\r\n  this.setData({\r\n    list: newData\r\n  })\r\n}\r\n复制代码使用wxParse解析HTML下载 wxParse ，放到utils目录下在JS页面引入： import WxParse from '../../utils/wxParse/wxParse'Page({\r\n  data:{\r\n    contentHTML:'' // 解析后的HTML\r\n  },\r\n  onLoad: function() {\r\n    // 请求到的HTML数据\r\n    let content = '<div>我是HTML代码</div>', that = this;\r\n    WxParse.wxParse('contentHTML', 'html', content, that, 0);\r\n  }\r\n})\r\n\r\n复制代码显示解析内容<import src=\"../../utils/wxParse/wxParse.wxml\"/>\r\n<view>\r\n  <!-- 显示内容 -->\r\n  <template is=\"wxParse\" data=\"{{wxParseData:contentHTML.nodes}}\" />\r\n</view>\r\n复制代码图片等比例image标签有个mode属性，可以设置图片如何显示，如果文档看的不仔细还真容易发现<image src=\"test.png\" mode=\"widthFix\"/>\r\n复制代码上拉加载和下拉刷新{\r\n  \"onReachBottomDistance\": 0,\r\n  \"enablePullDownRefresh\": true\r\n}\r\n复制代码data: {\r\n  limit: 30,\r\n  page: 1,\r\n  list:[],\r\n  count:0\r\n},\r\n// 下拉\r\nonPullDownRefresh: function () {\r\n  this.setData({\r\n    page: 1,\r\n    list:[]\r\n  })\r\n  this.getData()\r\n},\r\n// 上拉\r\nonReachBottom: function () {\r\n  if(this.data.list.length >= this.data.count) {\r\n    return false\r\n  }\r\n  this.setData({\r\n    page: this.data.page + 1\r\n  })\r\n  this.getData()\r\n  wx.stopPullDownRefresh()\r\n},\r\ngetData: async function () {\r\n  await wxRequest(app.globalData.baseUrl + '/test', {\r\n    data: {\r\n      page: this.data.page,\r\n      limit: this.data.limit,\r\n    }\r\n  }).then((ret) => {\r\n    let list = this.data.list.concat(ret.data.list)\r\n    this.setData({\r\n      list: list,\r\n      count: ret.data.count\r\n    })\r\n  })\r\n}\r\n复制代码上传图片任务：小程序上传图片到服务器，最多上传三张，前端可以删除图片效果图如下使用到的API有两个：wx.uploadFile wx.chooseImage示例WXML：<view class=\"sale after-pic\">\r\n  <block wx:for=\"{{imgList}}\" wx:key=\"{{index}}\">\r\n    <view class=\"pic\">\r\n      <image src=\"{{item}}\" />\r\n      <icon type=\"clear\" size=\"20\" catchtap=\"clearImg\" data-id=\"{{index}}\"/>\r\n    </view>\r\n  </block>\r\n  <image src=\"../../images/upload.png\" catchtap=\"chooseImage\" />\r\n</view>\r\n<button catchtap=\"onSub\">提交</button>\r\n复制代码imgList是wx.chooseImage成功后返回的图片临时地址示例JSPage({\r\n  data: {\r\n    imgList:[]\r\n  },\r\n  // 使用async await是因为图片上传是异步的\r\n  onSub: async function() {\r\n    // 点击提交后，开始上传图片\r\n     let imgUrls = []\r\n     for (let index = 0; index < this.data.imgList.length; index++) {\r\n       await this.uploadFile(this.data.imgList[index]).then((res) => {\r\n         // 这里要注意把res.data parse一下，默认是字符串\r\n         let parseData = JSON.parse(res.data)\r\n         imgUrls.push(parseData.data) // 图片地址\r\n       })\r\n     }\r\n     console.log(imgUrls) // 3张图片上传成功后，执行其他操作\r\n  },\r\n  // 删除某张图片\r\n  clearImg: function (params) {\r\n    let imgList = this.data.imgList\r\n    let id = params.currentTarget.dataset.id // 图片索引\r\n    imgList.splice(id, 1) // 删除\r\n    this.setData({\r\n      imgList: imgList\r\n    })\r\n  },\r\n  chooseImage: function (params) {\r\n    wx.chooseImage({\r\n      count: 3, // 做多3张\r\n      sizeType: ['original', 'compressed'],\r\n      sourceType: ['album', 'camera'],\r\n      success: (res) => {\r\n        // 存储临时地址\r\n        this.setData({\r\n          imgList: res.tempFilePaths\r\n        })\r\n      }\r\n    })\r\n  },\r\n  uploadFile: function (filePath) {\r\n    // 返回Promise是为了解决图片上传的异步问题\r\n    return new Promise( (resolve, reject) => {\r\n      wx.uploadFile({\r\n        url: app.globalData.baseUrl + '/file/upload', // 上传地址\r\n        filePath: filePath,\r\n        name: 'file', // 这里的具体值，问后端人员\r\n        formData: {},\r\n        header: {\r\n          \"Content-Type\": \"multipart/form-data\"\r\n        },\r\n        success: (res) =>{\r\n          // 图片上传成功后，后端会返回一个地址，可以把它存到imgUrls\r\n          this.imgUrls.push(res.data.data)\r\n        },\r\n        fail:(err) => {\r\n          console.log(err)\r\n        }\r\n      })\r\n    })\r\n  }\r\n})\r\n复制代码动态标题onLoad的时候动态设置标题wx.setNavigationBarTitle({\r\n  title: '新标题'\r\n})\r\n复制代码结语以上是仅为我个人在开发过程中遇到的一些问题，若有错误还请批评指正，感谢阅读."}
{"title": "微信公众号菜单配置小程序简易教程 ", "author": "天下雪", "pub_time": "2017-3-28 19:05", "content": "分享公众号中2种自定义菜单 配置跳转小程序：\r\n\r\n先提条件是你的公众号版定了小程序\r\n\r\n\r\n第一种：直接配置\r\n    \r\n\r\n第二张：代码配置\r\n\r\n  1、进入在线接口调试工具\r\n      2、选择自定义菜单\r\n\r\n\r\n菜单body为json格式:\r\n{\r\n    \"button\": [\r\n        {\r\n            \"type\": \"miniprogram\", \r\n            \"name\": \"合作\", \r\n            \"url\": \"http://form.mikecrm.com/2xb9aT\", \r\n            \"appid\": \"wx9505d4924d1948e7\", \r\n            \"pagepath\": \"pages/index/index\"\r\n        }\r\n    ]\r\n}\r\n点击检查问题就行了。"}
{"title": "微信小程序页面布局方式flexbox -温故而知新 ", "author": "天下雪", "pub_time": "2017-2-3 00:48", "content": "微信小程序使用flexbox容器，flexbox布局由伸缩容器和伸缩项目组成。任何一个元素都可以指定为flexbox布局，其中设为display:flex或者display:inline-flex的元素称为伸缩容器。伸缩容器的子元素称为伸缩项目，伸缩项目使用伸缩布局模型来排版。伸缩布局模型与传统的布局不一样，它按照伸缩流的方向布局。请看下面的经典图片默认情况下，伸缩容器由两根轴组成，主轴(main)和交叉轴(cross)，其中主轴的开始位置叫main start，结束位置叫main end。交叉轴的开始位置叫cross start，结束位置叫cross end 。伸缩项目的主轴上的占据空间叫main axis，在交叉轴上的占据位置叫cross axis，根据设置情况的不同。主轴既可以是水平轴，也可以是垂直轴。不论哪个轴作为主轴，默认情况下伸缩项目总是沿着主轴，从主轴开始位置到主轴结束位置进行排版，flexbox在浏览器使用需要加上各个浏览器的私有前缀,-webkit ,-moz,-ms,-o，微信小程序全部去掉前缀。伸缩容器支持的属性有：1,display2,flex-direction3,flex-wrap4,flex-flow5,justify-content6,align-items7,align-content8,order9,flex-grow10,flex-basis11,flex12,align-self主要介绍这几个属性 display该属性用来指定元素是否为伸缩容器，语法为display:flex    |   display:inline-flexwxml代码为:<view class=\"Container\">  <view class=\"sp1\">1</view>  <view class=\"sp2\">2</view>  <view class=\"sp3\">3</view>  <view class=\"sp4\">4</view>  <view class=\"sp5\">5</view>  <view class=\"sp6\">6</view>  <view class=\"sp7\">7</view>  <view class=\"sp8\">8</view>  <view class=\"sp9\">9</view></view>wxss代码为.container{display: flex;}flex:用于产生块级伸缩容器.container{display: inline-flex;}inline-flex:用于产生行内级伸缩容器，flex-direction该属性用于指定主轴方向，语法为flex-direction: row  | row-reverse  | column  | column-reverse1)row水平方向从左向右2)row-reverse水平方向从右向左4）column伸缩容器为垂直方向，伸缩项目的排版方式为从上到下5)column-reverse伸缩容器为垂直，伸缩项目为从下到上flex-wrap该属性用来指定伸缩容器的主轴线方向空间不足的情况下，是否换行以及该如何换行flex-wrap: nowrap | wrap  | wrap-reverse 1)nowrap空间不足是也不换行2)wrap空间不足可以换行3) wrap-reverse空间不足可以换行，若主轴为水平轴，则换行的方向为从下到上，和wrap相反flex-flow该属性是flex-direction和flex-wrap属性的缩写版本，它同时指定了伸缩容器的主轴和侧轴，其默认属性为row nowrapflex-flow: flex-direction | flex-wrapjustify-content该属性用来定义伸缩项目沿主轴线的对齐方式justify-content: flex-start | flex-end | center | space-between | space-around1)flex-start伸缩项目向主轴线的起始位置靠齐2)flex-end 伸缩项目向主轴线的结束位置对齐，3)center伸缩项目向主轴线的中间位置靠齐4)space-around伸缩项目会平均的分布在主轴线里，两端保留一半的空间。5)space-between伸缩项目会平分在主轴线里，第一个伸缩项目在主轴线的开始位置，最后一个伸缩项目在主轴线的终点位置align-items该属性用来定义伸缩项目在伸缩容器的交叉轴上的对齐方式align-items: flex-start | flex-end | center | baseline |  stretch;1)flex-start伸缩项目沿交叉轴的起始位置对齐2)flex-end沿交叉轴的结束位置对齐3)center伸缩项目沿交叉轴的中间位置靠齐4)baseline伸缩项目根据它们的基线对齐5)stretch伸缩项目在交叉轴方向拉伸填充整个伸缩容器align-content用来调整伸缩项目出现换行后在交叉轴上的对齐方式，类似于伸缩项目在主轴上使用justify-contentalign-content: flex-start | flex-end | center | space-between | space-around | stretch1)flex-start伸缩项目向交叉的起始位置靠齐2)flex-end伸缩项目向交叉轴的起始位置靠齐3)center伸缩项目向交叉轴的中间位置靠齐4)space-between伸缩项目在交叉轴中平均分布5)space-around伸缩项目在交叉轴平均分布，且两边各有一半空间6)strech伸缩项目将会在交叉轴上伸展以占用剩余空间order用于定义排列顺序，数值越小，排列越靠前，默认值为0flex-grow用于定义伸缩项目的放大比例，默认值0，即如果存在剩余空间，也不放大，如果所有伸缩项目的flex－grow设置为1，那么每个伸缩项目将设置为大小相等的剩余空间，如果你将其中一个flex－frow伸缩项设置为2，那么这个伸缩项目所占剩余空间是其他伸缩项目所占胜于空间的两倍flex-shrink该属性用来定义伸缩项目的收缩能力flex-basis该属性用来设置伸缩项目的基准值，剩余空间按比率进行伸缩flex该属性是flex-grow ,flex-shrink,flex-basis属性的缩写flex: none | flex-grow flex-shrink flex-basis其中第二个参数和第三个参数(flex-shrink,flex-basis)是可选参数，默认为0 1 auto本例子sp3原属宽度为50px，当是flex：1时，该元素就会把伸缩容器的剩余空间占满，其实质上就等于felx-grow:1该属性有两个快捷值:auto(1 1 auto)和none(0 0 auto)align-self用于设置单独的伸缩项目在交叉轴上的对齐方式，会覆盖默认的对齐方式align-self: auto | flex-start | flex-end | center | baseline | stretch1)auto2)felx-start沿交叉轴开始位置对齐3)flex-end沿交叉轴结束位置对齐4)center沿交叉轴中心位置对齐5)baseline沿交叉轴的基线对齐6)stretch沿交叉轴方向占满伸缩容器"}
{"title": "小程序的架构及实现机制，信道服务及会话管理 ", "author": "天下雪", "pub_time": "2017-2-9 00:04", "content": "本文来自公众号：小程序架构及实现机制小程序并不是 H5 应用，而是更偏向于传统的 CS 架构，它是基于数据驱动的模式，一切皆组件（视图组件）。所以建议在开发小程序时不要以web app的开发思维去思考。小程序开发语言是独立的一整套开发语言体系，既与Html+CSS+JavaScript一脉相承，而又有所区别，同时提供了各种自有的组件和 API。框架基本都是建立在window、document对象上，但小程序是没有window、document，或者说没有浏览器BOM这个宿主环境。你可以理解为小程序的宿主环境是类似node的宿主环境，而不是浏览器客户端。所以决定了无法使用Dom库，如JQuery。而又并非使用URL访问，而是通过信道服务进行通讯和会话管理，所以它不支持Cookie存储，同时访问不存在跨域问题。不兼容Html标记,而遵循XML语法，而提供自身封装类似的组件与API来实现页面展现。模块化，形式上支持CommonJs，加载引用更像ES6。小程序形式支持CommonJS，通过require加载，跟node、seajs类似。但是通过require加载的是引用的赋值，而不是CommonJS中的值的缓存。从框架组件设计来看，框架本身采用面向状态的编程方式，组件部分类似redux的设计（实际不是redux实现的）。组件的View在action操作后，只能通过action的业务处理进行更新View。而框架是单向数据绑定，无法自动更新。对于这一类View组件自带action的，建议进行必要再封装。封装可以考虑aop的方式动态的注册&卸载。对于业务页面的开发，可以将页面视为一个页面组件。在这个页面组件，完成了以下工作：负责初始化组件state（微信）负责组合子view组件形成页面效果（开发者）确定js 与view 匹配的数据（开发者）负责注册业务逻辑对象提供的业务逻辑方法（开发者）负责管理业务逻辑对象（开发者）页面wxml与页面js的通信如下（简化了微信框架的工作） 官方开发文档：https://mp.weixin.qq.com/debug/wxadoc/dev/index.html?t=20161107 知识储备基础:HTML+JS+CSS进阶：React、Vue语法：Mustache、XML规范：CommonJS微信小程序的架构一个小程序页面包含4个文件：1.WXML：页面结构  用于创建页面对象，以及处理页面生命周期控制和数据处理2.JS：页面逻辑  设置当前页面工作时的window的配置3.WXSS：页面样式 用于定义页面中元素结构，遵循XML语法，不是HTML语法，增加了flex布局4.JSON：页面配置 用于定义页面样式的，语法遵循CSS语法，扩展了CSS基本用法和长度单位小程序的实现机制小程序的开发是基于微信提供的一套应用框架进行开发的。微信通过封装微信客户端提供的文件系统、网络通信、任务管理、数据安全等基础功能，对上层提供了一套完整的Javascript Api，使得开发者能够非常方便的使用到微信客户端提供的各种基础功能，快速构建一个应用。框架设计如下：框架提供了自己的视图层描述语言 WXML 和 WXSS，以及基于 JavaScript 的逻辑层框架，并在视图层与逻辑层之间通过单向数据绑定进行数据传输，使开发者更加聚焦于数据与逻辑上。 信道服务与会话管理的实现信道服务是基于WebSocket完成的，而会话管理需要完成微信要求的鉴权流程。微信的请求接口 wx.request 并不支持 cookie 传递，所以会话层不能使用传统的 Session 方式。会话服务和信道服务与服务模块之间的关系小程序与业务服务器之间通信 信道服务是基于WebSocket实现的具体流程如下：小程序与业务服务器之间通信流程建立 WebSocket 连接的过程 会话管理的实现流程与鉴权流程如下：会话的建立流程会话的验证流程设计架构图"}
{"title": "微信小程序从使用到分析快速解析 ", "author": "yuzeng84", "pub_time": "2017-6-4 08:22", "content": "小程序从使用到分析快速解析\" style=\"margin: 35px 0px 20px; font-family: \" pingfang=\"\" sc\",=\"\" \"hiragino=\"\" sans=\"\" gb\",=\"\" \"helvetica=\"\" neue\",=\"\" \"microsoft=\"\" yahei\",=\"\" \"wenquanyi=\"\" micro=\"\" hei\",=\"\" sans-serif;=\"\" font-weight:=\"\" 500;=\"\" line-height:=\"\" 40px;=\"\" color:=\"\" rgb(44,=\"\" 62,=\"\" 80);=\"\" text-rendering:=\"\" optimizelegibility;=\"\" font-size:=\"\" 26px;=\"\" background-color:=\"\" rgb(249,=\"\" 249,=\"\" 245);\"=\"\">微信小程序从使用到分析快速解析一、微信小程序简介微信小程序是腾讯微信团队推出的基于微信生态的应用号，是一种跨平台，媲美原生App操作体验的web应用，它拥有，即用即走、离线存储、跨平台等特点。1、系统架构小程序大概的系统架构如下图所示： Page Frame：Web应用在微信下实现如原生应用般顺滑的体验，主要靠Page Frame，Native会预先加载一个WebView，当打开小程序落地页面的时候，就直接通过下载CDN上的资源以及数据渲染页面，请求数据则局部刷新，页面返回直接history弹栈，退出小程序，View状态并不会销毁。3、MVVM微信小程序的前端架构设计，以及开发模式，充分参考了Vue、React这一类MV*的前端开发框架，我们简单举几个例子： 比如通过{{data-bind}}进行数据双像绑定，就像极了Vue的设计风格； 再比如一些标签语法糖，列表循环： wx:for=\"{{array}}\"> {{item}} 相信写过AngularJS 和 Vue的同学都不会陌生； 再比如，事件绑定：     bindtap=\"add\"> {{count}} Page({    data: {      count: 1    },    add: function(e) {        this.setData({ data: this.data.count + 1        })    }})如果你开发过React，那么其里面有一个setState的方法可以用来改变状态的值，这里的setDate也是一样的，通过绑定的add方法来改变视图中count的值。 模块化思想这些都是现在前端框架必备基础。4、组件微信小程序框架与其他开发框架不同，比如vue react都是只管安心做好框架，UE层面的套件库都由各路使用者来贡献，比如饿了么的element，蚂蚁的ant-design，微信小程序直接提供了在小程序开发过程中常用的UE组件，小程序的组件遵循web component标准，并使用polymer框架实现web component。 视图容器、表单组件、导航、媒体组件、地图组件、画布这些基础的元素级组件 分享、登录、支付这些功能性组件5、API在appservice层，微信提供了N多API，其实就是jsbridge，用于提供js访问native的能力和通道，像：wx.storage访问存储相关接口wx.file 文件操作相关apiwx.systeminfo获取机型wx.network 获取联网状态还有更多媒体、界面的操作api不一一列举，可以直接参考文档-开发-API部分二、利用分析工具透视微信小程序当简单了解了小程序是什么之后，我们摸索着做了一个小程序的demo，利用豆瓣图书的api（做完了才发现git上已经有无数这样的demo），成功运行小程序之后，我们又有了对小程序做数据透视的想法，官方的数据分析模块有提供，但及其简单，只是基础的运营指标+自定义事件（自定义事件功能还是蛮屌的，实现了无埋点），业界搜索了一下，有微信小程序分析相关的平台or产品并不多，talkding data，hotapp，腾讯移动分析(MTA)，本着对大公司的信赖，选择了MTA，接下来就针对MTA的sdk代码和功能，来看看如何利用数据分析工具运营小程序。1、数据分析SDK源码解读：整个SDK对外暴露了三个对象App、Page、Eventmta.App.init({config_obj});做统计信息的初始化，在应用入口app.js App.onLaunch方法中调用，很显然是做一些统计信息初始化的工作，其中除了常规的统计ID的初始化，我们发现有对使用分析统计功能的开关设计，通过反混淆源码发现： 以统计分享为例：var a = getCurrentPages()[getCurrentPages().length - 1];MTA_CONFIG.stat_share_app && a.onShareAppMessage && !            function() {                var b = a.onShareAppMessage;                a.onShareAppMessage = function() {                    MTA.Event.stat(MTA_CONFIG.prefix + \"shareapp\", {                        url: a.__route__                    });                    return b.call(this, arguments)                }            } ()获取当前页面的对象，重载页面对象的share event对应的handler方法，在执行框架方法之前，做统计平台的event统计上报，是个不错的好方法。Page.init()具体页面的统计接口，可以看到，页面的访问统计是挂在框架对外暴露的Page.onShow的方法，onShow方法会在加载，返回，后台导前台等页面展示的任何时机都上报，所以统计口径可能与官方有差异Event.stat(eventid, {params_obj})自定义事件的上报接口，用户可以在管理台配置好自定义事件，拿到合法的统计id和事件id后，在任何需要统计的事件场景下进行统计 其他内部实现，多是利用框架提供的system/network等接口来上报环境、网络等信息2、实时刷新的透视数据MTA提供了访问次数、访问人数、应用打开次数等基础指标在各个分析模型下的组合、计算和应用，并且做到了几乎全站分析模型的实时化： 真正做到了所见即所得的运营数据3、环境分析，让微信小程序开发者更了解运行环境MTA提供了地域、运营商那个、机型、网络、操作系统、平台等一系列用户客户端环境分析的报表，可以很好的帮助开发者、运营者了解自己的小程序都运行在什么的宿主环境中，其中地域分析提供了各省份及其附属市区的覆盖数据，这些应该都是拿的用户ip，然后匹配腾讯公共的ip库做的映射： 而微信版本、网络连接类型、机型、操作系统等这些都是利用微信的getSysteminfo getNetworkType等接口取值上报进行了汇总、统计： 4、使用分析，特定场景下的用户行为分析以上两个功能都是不需要用户参与的，MTA自动帮大家采集和计算的，而使用分析则不是，比如我们需要统计有多少用户分享了我的小程序、有多少用户触发了页面的下拉刷新等动作，如此精细化的用户行为分析，MTA这边也提供了配置化的上报接口：在mta.App.init({        \"statPullDownFresh\":true,       \"statShareApp\":true,           \"statReachBottom\":true})前提是已经获得并配置了合法的click_id 这样平台就会采集这样的用户行为数据，并进行计算 举例分享分析，还提供了具体的分享页面列表，让开发者了解自己的小程序哪些页面的内容质量更高。5、自定义分析，给用户行为洞察更多的灵活性有很多场景，比如我想统计demo小程序中，搜索图书这个按钮的点击量（搜索图书这个事件的事件发生次数），并且我想知道每次用户都输入了什么值来搜索图书，我用MTA的自定义事件，并配置了对应的事件id和参数mta.Event.stat('btn_search',{search:'用户输入的值'})6、实时访客轨迹，实时透视用户行为的鹰眼这个功能是我觉着帮助透视小程序运营数据很有特色的一个功能，可以帮助开发者实时的查看当前应用的活跃用户的行为轨迹，并且提供了当前用户的一些基本属性：第一次访问小程序的时间，用户类型，地域，受访页面url等，很清晰，有种坐在monitor屏幕后面窥视用户的感觉： 目前利用诸如MTA这样的小程序数据分析平台来做小程序的基础和精细化运营还是很不错的，期待有更多用户洞察的功能以及对小程序开发者和运营者更有价值的功能推出。"}
{"title": "Codeigniter中创建LeanCloud云函数实现微信支付 ", "author": "yuzeng84", "pub_time": "2017-6-4 08:34", "content": "经过摸索，与官方提供的slim无异，同样使用__invoke魔法函数即可，步骤如下：1.config.php打开hook，即设置$config['enable_hooks'] = TRUE;详情文档参见：http://codeigniter.org.cn/user_guide/general/hooks.html2.在hook.php中实现php"}
{"title": "微信小程序组件之marquee ", "author": "Rolan", "pub_time": "2017-6-23 00:04", "content": "1. marquee标签html是有marquee标签的，可以实现跑马灯效果，但小程序没有，所以要实现。这里考虑使用css3的animation实现。html的marquee是这样使用的。\"left\" behavior=\"scroll\" scrollamount=\"1\" scrolldelay=\"0\" loop=\"-1\" width=\"200\" height=\"50\" bgcolor=\"#0099FF\" hspace=\"10\" vspace=\"10\">      hello world2. wxml<view class=\"marquee_container\" style=\"--marqueeWidth--:{{-marquee.width}}em\">    <view class=\"marquee_text\">{{marquee.text}}view>view>传入wxml的是个json对象marquee:{    width:12,    text:'hello world'}而那个奇怪的–marqueeWidth是给@keyframes传的变量。内联设置变量，css文件中也可以获取到该变量。3. wxss@keyframes around {    from {      margin-left: 100%;    }    to {      margin-left: var(--marqueeWidth--);// var接受传入的变量    }  }.marquee_container{  background-color: #0099FF;  height: 1.2em;  position: relative;  width: 100%;}.marquee_container:hover{  animation-play-state: paused; // 不起作用}.marquee_text{  display: inline-block;  white-space: nowrap;  animation-name: around;  animation-duration: 5s;  animation-iteration-count: infinite;  animation-timing-function:linear;}4. jsexport default {  getWidth:(str)=>{    return [].reduce.call(str, (pre, cur, index, arr) => {      if (str.charCodeAt(index) > 255) {// charCode大于255是汉字        pre++;      } else {        pre += 0.5;      }      return pre;    }, 0);  },  getDuration:(str)=>{// 保留，根据文字长度设置时间    return this.getWidth()/10;  }}以上是组件的封装。5. 使用// wxml\"../component/marquee/marquee.wxml\" />// wxss@import \"../component/marquee/marquee.wxss\";// jsimport marquee from '../component/marquee/marquee.js';var options = Object.assign(marquee, {  data: {    motto: 'Hello World',    userInfo: {},    marquee: { text: '你好，中国！hello,world!' }  },  onLoad: function () {    // ...    const str = this.data.marquee.text;    const width = this.getWidth(str);    console.log('width',width);    this.setData({ [`${'marquee'}.width`]: width });  }});Page(options);ni"}
{"title": "小程序没有授权时的处理方法 ", "author": "Rolan", "pub_time": "2017-6-26 00:38", "content": "在做小程序开发的时候，我们经常会需要获取用户的一些权限。比如获取用户信息用于直接登录，获取地理位置用于定位等。但要是用户拒绝授权了，该怎么处理呢？问题分析在小程序里面，获取到用户权限是进行某些操作的必要前提。比如在进入小程序的时候，获取到用户信息，拿到 unionId 对应到自己平台的账号进行登录，免去用户自己输入账号密码，这就是一个不错的体验。当我们调用 wx.getUserInfo 或者 wx.getLocation 这种需要用户授权的 API 时，小程序会弹框让用户选择授权：当用户选择允许后，下次再进入小程序就不会再询问了，直接获得用户授权（除非将小程序删了再进入）。这里的问题在于，当用户点了拒绝之后，就拿不到相关授权了，并且在一段时间内，进入小程序都不会再出现这个弹框。从用户体验及保护隐私的角度考虑，小程序最好是不用授权也可以使用（或者体验）。但有些类型的小程序确实是需要拿到用户信息才能使用的。这里提供一个简单的解决方案。解决方案以获取用户信息直接登录为例。增加一个授权页面，作为进入小程序的第一个页面，在这里获取用户数据和登录。默认可以什么都不显示，也可以当做引导页来使用。获取用户信息需要用到 wx.login 和 wx.getUserInfo 两个 API，关于这两个 API 的具体信息大家可以到官方文档去查看。增加一个登陆方法，代码如下：//登录\r\nlogin: function () {\r\n  var that = this\r\n  if (typeof success == \"function\") {\r\n    this.data.getUserInfoSuccess = success\r\n  }\r\n  wx.login({\r\n    success: function (res) {\r\n      var code = res.code;\r\n      wx.getUserInfo({\r\n        success: function (res) {\r\n          //平台登录\r\n        },\r\n        fail: function (res) {\r\n          that.setData({\r\n            getUserInfoFail: true\r\n          })\r\n        }\r\n      })\r\n    }\r\n  })\r\n}当上门代码走到了 fail 里面，就可以认为在获取授权的时候，用户点了拒绝。当 getUserInfoFail 为 true 的时候，可以展示一个获取授权的按钮，比如像这样：接下来介绍另一个 API : wx.openSetting，使用 wx.openSetting 可以跳转到小程序的授权设置界面，在安卓里面它长这样：在点击授权按钮后跳转到这里，让用户授权了才给进入首页，否则就停留在授权页面。但还有个小问题，这个 API 是基础库 1.1.0 才有的，所以需要做兼容处理：所以，最终跳转授权的代码如下：//跳转设置页面授权\r\nopenSetting: function () {\r\n  var that = this\r\n  if (wx.openSetting) {\r\n    wx.openSetting({\r\n      success: function (res) {\r\n        //尝试再次登录\r\n        that.login()\r\n      }\r\n    })\r\n  } else {\r\n    wx.showModal({\r\n      title: '授权提示',\r\n      content: '小程序需要您的微信授权才能使用哦~ 错过授权页面的处理方法：删除小程序->重新搜索进入->点击授权按钮'\r\n    })\r\n  }\r\n}还好 1.1.0 已结算是比较早的版本了，现在都出到 1.3.0 了。最终效果如下：同样的处理方式也可以用在获取别的权限上，妥妥的。"}
{"title": "小程序组件实现 ", "author": "Rolan", "pub_time": "2017-6-30 00:49", "content": "最近在做小程序项目，由于是多人开发，首先要考虑项目组件的实现，俗话说的好：“项目未动，组件先行”~组件我用的是小程序的template，先上项目的目录架构form-action-sheet组件wxml代码<template name=\"form-action-sheet\">\r\n  <action-sheet hidden=\"{{actionSheetHidden}}\" bindchange=\"actionSheetChange\">\r\n    <block wx:for=\"{{actionSheetItems}}\">\r\n      <action-sheet-item bindtap=\"itemChange\" class=\"item\" data-id=\"{{item.id}}\">\r\n          {{item.name}}\r\n      </action-sheet-item>\r\n    </block>\r\n    <action-sheet-cancel class=\"cancel\">取消</action-sheet-cancel>\r\n  </action-sheet>\r\n</template>在具体页面引用：import引入template资源<import src=\"../../compoent/form-action-sheet/form-action-sheet.wxml\" />调用template并传入数据<view bindtap=\"showHideActionSheet\">\r\n  <template is=\"form-select-default\" data=\"{{...permis}}\"/>\r\n</view>permis数据必须在data上声明：permis: {\r\n  title: '权限设置',\r\n  name: '所有人可见',\r\n  icon: '../../img/p.png',\r\n},绑定事件actionSheetChange：showHideActionSheet: function() {\r\n  wx.showActionSheet({\r\n    itemList: params,\r\n    success: function(res) {\r\n      success(res);\r\n    },\r\n    fail: function(res) {\r\n      fail(res);\r\n    }\r\n  })\r\n}这里遇到巨坑的问题是，事件不能以变量的形式传入template，即如果需要在template上绑定如bindtap事件的话，事件名不能从具体调用页面中传入变量上面代码中要给bindchange事件传一个函数的话只能传具体函数名，不能传入变量。。。也就是说以template实现的组件需要绑定事件要么把事件实现放在具体调用页面中通过外围包裹一个view元素传入事件也就是<view bindtap=\"showHideActionSheet\">\r\n  <template is=\"form-select-default\" data=\"{{...permis}}\"/>\r\n</view>要么就在template里面写死，这种组件在调用页面中只能用一次，不然多个组件只能共用一个事件。综上，template实现组件形式要做到良好封装性还要等微信开放相关功能才能实现了，目前只能带着手铐上路。"}
{"title": "分享一个同城拼车的微信小程序（前端+后端） ", "author": "vinceth520", "pub_time": "2017-7-15 13:30", "content": "因为五一的时候回家买票难，然后就在网上搜了一下当地的门户论坛，居然发现有拼车信息，一番联系顺利拼车回家，不仅方便而且便宜，于是突发奇想，自己做一个拼车的网站或程序，又看到没出不久的微信小程序，于是决定写一个微信小程序，但是当小程序制作完成审核上线才发现，由于没有公司资质，并不能上线此小程序，于是决定将代码分享出来，给新手玩家学习交流。以下是github链接：前端：https://github.com/vincenth520/pinche_xcx后端：https://github.com/vincenth520/pinche_xcx_data"}
{"title": "解决繁琐的小程序会话管理，自带登录态管理的网络请求组件 ... ... ", "author": "Rolan", "pub_time": "2017-8-4 00:01", "content": "登录时序图下图是小程序官方文档中的登录时序图。此图涵盖了前后端，详细讲解了包括登录态的生成，维护，传输等各方面的问题。发起网络请求的流程图具体到业务开发过程中的前端来说，我认为上图还不够完整，于是我画了下面这张以前端逻辑为出发点的、包含循环的流程图。 我认为前端每一次发起网络请求，跟后台进行数据交互，都适用于下图的流程： hasChecked： 用一状态标识本生命周期内是否执行过wx.checkSession，判断该标识，若否，开始执行wx.checkSession，若是，进入下一步wx.checkSession()： 调用接口判断登录态是否过期，若是，重新登录；若否，进入下一步wx.checkSession()是小程序提供的检测登录态是否过期的接口，生命周期内只需调用一次即可。用户越久未使用小程序，用户登录态越有可能失效。反之如果用户一直在使用小程序，则用户登录态一直保持有效。具体时效逻辑由微信维护，对开发者透明wx.getStorage(session)： 尝试获取本地的session。如果之前曾经登录过，则能获取到；否则，本地无sessionwx.login()： 小程序提供的接口，用于获取code（code有效期为5分钟）wx.request(code)： 将code通过后台提供的接口，换取sessionwx.setStorage(session)： 将后台接口返回的session存入到localStorage，以备后续使用wx.request(session)： 真正发起业务请求，请求中带上sessionparse(data)： 对后台返回的数据进行预解析，若发现登录态失效，则重新执行登录；若成功，则真正获取到业务数据拓展小程序网络请求的能力只要遵循上图的流程，我们就无需在业务逻辑中关注登录态的问题了，相当于把登录态的管理问题耦合到了发起网络请求当中。 一般情况下，我们程序设计都会遵循模块解耦的原则，尽可能将模块颗粒化到最小。这导致可能有些同学认为模块耦合不是好事情，但是我认为这是要分情况的：小程序区别与传统的H5，不支持cookies，在代码层级上讲，这无形中就给登录态的管理增加了复杂度：cookies会在H5的每个请求中自动带上，但小程序的请求却每次都需要手动带上登录态参数小程序区别于基于公众号登录的H5来说，又存在一定的优势：登录授权时并不需要多次的页面跳转（Oauth），也正因为如此，小程序的请求在登录态失效时，需要具备重新登录并自动重试请求的能力（无页面刷新感，用户甚至都不能感知到进行了重新登录）以上两点虽然是登录态管理的问题，但从另外一个角度去理解，我更认为它是小程序网络请求的能力问题，所以，我认为通过拓展小程序网络请求能力来实现登录态的自动管理是非常合适的。通用组件——weRequest一个通过拓展wx.request，从而实现自动管理登录态的组件。 先来看看怎么使用：var weRequest= require('../weRequest');\r\n\r\n// 初始化配置\r\nweRequest.init({\r\n    // 关于配置内容，将在后文详述\r\n    // 此处暂时省略...\r\n})\r\n\r\n// 发起请求\r\nweRequest.request({\r\n    url: 'order/detail',\r\n    data: {\r\n        id: '107B7615E04AE64CFC10'\r\n    },\r\n    success: function (data) {\r\n\t\t// 省略...\r\n    }\r\n})引入weRequest组件初始化组件配置就像使用wx.request那样去使用它自动带上登录态参数我们来看看执行上面代码的DEMO效果： 可以看到，通过weRequest发出的请求，将会自动带上登录态参数。 对应的流程为下图中红色的指向： 没有登录态时，自动登录那如果当前小程序并没有登录态的情况又会如何呢？ 接下来我们来看看本地无登录态情况下的模拟： 当本地没有登录态时，按照流程图，weRequest将会自动执行wx.login()后的一系列流程，得到code并调用后台接口换取session，储存在localStorage之后，重新发起业务请求。 对应的流程为下图中红色的指向： 登录态过期时，自动重新登录接下来我们再来看看，当本地储存的登录态过期之后，页面的行为如何： 对后台数据进行预解析之后，发现登录态过期，于是重新执行登录流程，获取新的session之后，重新发起请求。 对应的流程为下图中红色的指向： 组件的配置项weRequest提供一个init方法，用于对组件的配置，以下展示所有的配置项：weRequest.init({\r\n    // 储存在localStorage的session名称，且CGI请求的data中会自动带上以此为名称的session值；可不传，默认为session\r\n    sessionName: \"session\",\r\n    // 请求URL的固定前缀；可不传，默认为空\r\n    urlPerfix: \"https://www.example.com/\",\r\n    // 触发重新登录的条件，res为CGI返回的数据\r\n    loginTrigger: function (res) {\r\n        // 此处例子：当返回数据中的字段errcode等于-1，会自动触发重新登录\r\n        return res.errcode == -1;\r\n    },\r\n    // 用code换取session的CGI配置\r\n    codeToSession: {\r\n        // CGI的URL\r\n        url: 'user/login',\r\n        // 调用改CGI的方法；可不传，默认为GET\r\n        method: 'GET',\r\n        // CGI中传参时，存放code的名称，此处例子名称就是code；可不传，默认值为code\r\n        codeName: 'code',\r\n        // CGI中返回的session值\r\n        success: function (res) {\r\n            // 此处例子：CGI返回数据中的字段session即为session值\r\n            return res.session;\r\n        }\r\n    },\r\n    // 登录重试次数，当连续请求登录接口返回失败次数超过这个次数，将不再重试登录\r\n    reLoginLimit: 2,\r\n    // 触发请求成功的条件\r\n    successTrigger: function (res) {\r\n        // 此处例子：当返回数据中的字段errcode等于0时，代表请求成功，其他情况都认为业务逻辑失败\r\n        return res.errcode == 0;\r\n    },\r\n    // 成功之后返回数据；可不传\r\n    successData: function (res) {\r\n        // 此处例子：返回数据中的字段data为业务接受到的数据\r\n        return res.data;\r\n    },\r\n    // 当CGI返回错误时，弹框提示的标题文字\r\n    errorTitle: function(res) {\r\n        // 此处例子：当返回数据中的字段errcode等于0x10040730时，错误弹框的标题是“温馨提示”，其他情况下则是“操作失败”\r\n        return res.errcode == 0x10040730 ? '温馨提示' : '操作失败'\r\n    },\r\n    // 当CGI返回错误时，弹框提示的内容文字\r\n    errorContent: function(res) {\r\n        // 此处例子：返回数据中的字段msg为错误弹框的提示内容文字\r\n        return res.msg\r\n    }\r\n})让业务逻辑更专注，不用再关注底层登录态问题小程序对比以往的H5，登录态管理逻辑要复杂很多。通过weRequest这个组件，希望能帮助开发者把更多精力放在业务逻辑上，而登录态管理问题只需通过一次简单配置，以后就不用再花精力管理了。FAQ我希望在请求时候，页面能出现最简单的loading状态，该怎么办？只需要在请求的时候，加上参数showLoading: true即可，如：weRequest.request({\r\n    url: 'order/detail',\r\n    showLoading: true,\r\n    data: {\r\n        id: '123'\r\n    },\r\n    success: function (data) {\r\n        console.log(data);\r\n    }\r\n})当然，如果你希望使用个性化的loading样式，你可以直接使用beforeSend参数来进行自定义展示个性化的loading，并且在complete的时候将它隐藏。某些请求在返回错误时，我不希望触发通用的错误提示框，而想用特别的逻辑去处理，该怎么办？只需要在请求的时候，加上参数fail: function(){ ... }即可，如：weRequest.request({\r\n    url: 'order/detail',\r\n    slience: true,\r\n    data: {\r\n        id: '123'\r\n    },\r\n    success: function (data) {\r\n        console.log(data);\r\n    },\r\n    fail: function(res) {\r\n        console.log(res);\r\n    }\r\n})此时，如果接口返回错误码，将触发这里定义的fail函数，且默认错误弹框将不会出现。为什么工具在发起请求之前，不主动去判断第三方session是否过期，而要通过接口结果来判断，这不是浪费了一次请求往返吗？每个小程序对于自身生成的session都有自己的一套管理方案，微信官方也没有指明一套通用的方案来要求开发者，仅仅要求了应该保证其安全性且不应该设置较长的过期时间。 原文如下：通过 wx.login() 获取到用户登录态之后，需要维护登录态。开发者要注意不应该直接把 session_key、openid 等字段作为用户的标识或者 session 的标识，而应该自己派发一个 session 登录态（请参考登录时序图）。对于开发者自己生成的 session，应该保证其安全性且不应该设置较长的过期时间。session 派发到小程序客户端之后，可将其存储在 storage ，用于后续通信使用。因此，不能要求所有后端接口都要返回session的过期时间给前端，甚至有些后端逻辑对于session的管理是动态的，会随调用情况来更新session的生命周期，这样的话逻辑就更复杂了。但是无论任何一种管理策略，都必须会有兜底策略，即前端传入过期的session，后端必须要返回特定标识告知前端此session过期。因此作为一个通用的工具组件，我需要确保更多的开发者能够低门槛地使用，所以并没有针对各种特别策略去优化，而且我相信，对于正常使用小程序的用户来说，登录态过期是一个相对低概率的事情，对整体效率性能来说，是微乎其微的，使用通用的兜底策略去应对这种情况，我认为已经是足够的了。"}
{"title": "营销组件--大转盘\\刮刮乐\\老虎机\\跑马灯\\九宫格翻纸牌\\摇一摇\\手势解锁 ... ", "author": "Rolan", "pub_time": "2017-9-18 11:04", "content": "营销组件营销组件， WeChat marketing components.支持营销类型大转盘刮刮乐老虎机跑马灯九宫格翻纸牌摇一摇手势解锁如何使用1.拉取仓库git clone git@github.com:pfan123/wx-market.git\r\n2.安装包依赖npm i \r\n3.查看组件文件大转盘（Rotate）: /pages/rotate/utils/刮刮乐 (scratch ticket) : /pages/scratch/utils/老虎机\t（slot machine） : /pages/slotmachine/utils/跑马灯 （marquee）: /pages/marquee/utils/九宫格翻纸牌 (grid card): /pages/gridcard/utils/摇一摇 (shake): /pages/shake/utils/手势解锁 (gesture lock): /pages/gestureLock/utils/4.使用引入方式拷贝所需组件，到小程序目录pages路由目录➀使用大转盘组件WXSS中引用样式：@import './utils/dial.wxss'WXML中引用结构：<import src=\"./utils/dial.wxml\"/>JS中引用：import Dial from './utils/dial.js'JS中实例调用：   let dial = new Dial(this, {\r\n     areaNumber: 8,   //抽奖间隔\r\n     speed: 16,       //转动速度\r\n     awardNumer: 2,    //中奖区域从1开始\r\n     mode: 1,    //1是指针旋转，2为转盘旋转\r\n     callback: () => {\r\n       //运动停止回调  \r\n     }\r\n   })➁使用刮刮乐组件WXML中引用结构：<import src=\"./utils/scratch.wxml\"/>JS中引用：import Scratch from './utils/scratch.js'JS中实例调用：  this.scratch = new Scratch(this, {\r\n    canvasWidth: 197,   //画布宽带\r\n    canvasHeight: 72,  //画布高度\r\n    imageResource: './images/placeholder.png', //画布背景\r\n    r: 4, //笔触半径\r\n    awardTxt: '中大奖', //底部抽奖文字\r\n    awardTxtColor: \"#1AAD16\", //画布颜色\r\n    awardTxtFontSize: \"24px\", //文字字体大小\r\n    callback: () => {\r\n      //清除画布回调\r\n    }\r\n  })注意：小程序无globalCompositeOperation = 'destination-out'属性，所以采用 clearRect 做擦除处理➂使用老虎机组件WXSS中引用样式：@import './utils/machine.wxss'WXML中引用结构：<import src=\"./utils/machine.wxml\"/>JS中引用：import Machine from './utils/machine.js'JS中实例调用：   this.machine = new Machine(this, {\r\n     height: 40,  //单个数字高度\r\n     len: 10,     //单个项目数字个数\r\n     transY1: 0,\r\n     num1: 3,    //结束数字\r\n     transY2: 0,\r\n     num2: 0,    //结束数字\r\n     transY3: 0,\r\n     num3: 0,  //结束数字\r\n     transY4: 0,\r\n     num4: 1,  //结束数字\r\n     speed: 24,  //速度\r\n     callback: () => {\r\n         //停止时回调        \r\n     }      \r\n   })➃使用跑马灯组件WXSS中引用样式：@import './utils/marquee.wxss'WXML中引用结构：<import src=\"./utils/marquee.wxml\"/>JS中引用：import Marquee from './utils/marquee.js'JS中实例调用：  this.marquee = new Marquee(this, {\r\n    len: 9, //宫格个数\r\n    ret: 9, //抽奖结果对应值1～9\r\n    speed: 100,  // 速度值\r\n    callback: () => {\r\n      //结束回调    \r\n    }            \r\n  })➄使用九宫格翻纸牌组件WXSS中引用样式：@import './utils/card.wxss'WXML中引用结构：<import src=\"./utils/card.wxml\"/>JS中引用：import Card from './utils/card.js'JS中实例调用： this.card = new Card(this,{\r\n   data: [   //宫格信息，内联样式、是否是反面、是否运动、对应奖项\r\n     {inlineStyle: '', isBack: false, isMove: false, award: \"一等奖\"},    \r\n     {inlineStyle: '', isBack: false, isMove: false, award: \"二等奖\"},\r\n     {inlineStyle: '', isBack: false, isMove: false, award: \"三等奖\"},\r\n     {inlineStyle: '', isBack: false, isMove: false, award: \"四等奖\"},\r\n     {inlineStyle: '', isBack: false, isMove: false, award: \"五等奖\"},\r\n     {inlineStyle: '', isBack: false, isMove: false, award: \"六等奖\"},\r\n     {inlineStyle: '', isBack: false, isMove: false, award: \"七等奖\"},\r\n     {inlineStyle: '', isBack: false, isMove: false, award: \"八等奖\"},\r\n     {inlineStyle: '', isBack: false, isMove: false, award: \"九等奖\"}\r\n   ],\r\n   callback: (idx, award) => {\r\n     //结束回调， 参数对应宫格索引，对应奖项    \r\n   }\r\n })➅使用摇一摇组件WXSS中引用样式：@import './utils/shake.wxss'WXML中引用结构：<import src=\"./utils/shake.wxml\"/>JS中引用：import Shake from './utils/shake.js'JS中实例调用：  this.shake = new Shake(this, {\r\n    shakeThreshold: 70, //阈值\r\n    callback: () => {\r\n          \r\n    }            \r\n  })➆使用手势解锁组件WXSS中引用样式：@import './utils/lock.wxss'WXML中引用结构：<import src=\"./utils/lock.wxml\"/>JS中引用：import Lock from './utils/lock.js'JS中实例调用： this.lock = new Lock(this, {\r\n   canvasWidth: 300,\r\n   canvasHeight: 300,\r\n   canvasId: 'canvasLock',\r\n   drawColor: '#3985ff'        \r\n })"}
{"title": "截图组件welCropper，实现原理及其使用 ", "author": "Rolan", "pub_time": "2017-9-25 00:04", "content": "封面\r\n\r\n最近做项目的时候，需要做一个截图功能。用了一个别人写的截图工具，发现截出的图质量下降了，但是我们图片要用来做识别, 需要保证截出的图质量不下降。而且也不支持通过拖动来调整截图框的大小。所以这个截图工具无法满足需求。因为所以，就自己动手写了一个截图组件。\r\n下面介绍一下实现原理和使用方法。\r\n实现原理\r\n组件wxml的层次结构图如下：\r\nhierarchy.png\r\n\r\n\r\n\r\noriginal canvas 用来绘制原图大小的图片，这样能保证截图后的质量不会下降，这个canvas是隐藏的。\r\n\r\nmovable-area是movable-view的容器，是官方提供的拖拽移动组件，用来移动截取框的四个角。这个组件支持多个点同时移动。\r\n\r\nscale canvas用来绘制适应屏幕比例大小的图片（aspectFit），因为通常原图大小是超过屏幕长宽的。\r\n\r\nmove canvas是根据四个movable-view的位置绘制出截图框。\r\n最后截图，通过四个点的位置计算出截图框的位置，然后放大对应原图大小的位置，得到在原图中的(x, y, width, height)，最后通过官方提供的canvas接口截图。wx.canvasToTempFilePath({  x: x,  y: y,  width: w,  height: h,  destWidth: w,  destHeight: h,  canvasId: 'originalCanvas',  success: function (res) {  })}\r\n最后截图，通过四个点的位置计算出截图框的位置，然后放大对应原图大小的位置，得到在原图中的(x, y, width, height)，最后通过官方提供的canvas接口截图。\r\n特点\r\n\r\n保证截图质量不会被压缩\r\n截图框能够通过拖拽来调整大小\r\n\r\n使用假设我们的应用文件结构如下：./├── app.js├── app.json├── app.wxss├── pages│   └── index│       ├── index.js│       ├── index.json│       ├── index.wxml│       └── index.wxss└── welCropper    ├── welCropper.js    ├── welCropper.wxml    └── welCropper.wxss调用组件时，需要传入cropperData和cropperMovableItems，因为数据和事件都是绑定在Page上的，所以要避免使用组件里面已经被占用的命名。 /pages/index/index.wxml<!-- 引入组件 --><import src=\"/welCropper/welCropper.wxml\" /><!-- 调用组件 --><template is=\"welCropper\" data=\"{{data:cropperData, cropperMovableItems:cropperMovableItems}}\"></template><!-- 用于选择图片，传入cropper中 --><button bindtap='selectTap'>select image</button>/pages/index/index.js// 获取显示区域长宽const device = wx.getSystemInfoSync()const W = device.windowWidthconst H = device.windowHeight - 50let cropper = require('../../welCropper/welCropper.js');console.log(device)Page({    data: {    },    onLoad: function () {        var that = this        // 初始化组件数据和绑定事件        cropper.init.apply(that, [W, H]);    },    selectTap() {        var that = this        wx.chooseImage({            count: 1, // 默认9            sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有            sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有            success(res) {                const tempFilePath = res.tempFilePaths[0]                console.log(tempFilePath)                // 将选取图片传入cropper，并显示cropper                that.showCropper(tempFilePath, (resPath) => {                    console.log(\"crop callback:\" + resPath)                    wx.previewImage({                        current: '',                        urls: [resPath]                    })                    // that.hideCropper() //隐藏，我在项目里是点击完成就上传，所以如果回调是上传，那么隐藏掉就行了，不用previewImage                })            }        })    }})最后引入组件的样式 /pages/index/index.wxss@import \"/welCropper/welCropper.wxss\";\r\n效果图\r\n效果动图\r\n\r\n截图\r\n\r\n如果将movable-view显示出来是这样的：\r\n显示movable-view后\r\n\r\n源代码：\r\nGithub:tomfriwel/welCropper，将welCropper文件夹复制到自己项目，引入调用就行了。\r\n如果出现什么bug、问题或者建议可以告诉我，我会尽量改进。"}
{"title": "微信小程序时间预约插件（包含日历） ", "author": "Rolan", "pub_time": "2017-10-31 00:29", "content": "因为项目需要，做了一个类似电商的时间预约功能，觉得有用，就独立出来成了个小插件。部分js代码var that=this;    function getThisMonthDays(year, month) {      return new Date(year, month, 0).getDate();    }  // 计算每月第一天是星期几    function getFirstDayOfWeek(year, month) {    return new Date(Date.UTC(year, month - 1, 1)).getDay();    }    const date = new Date();    const cur_year = date.getFullYear();    const cur_month = date.getMonth() + 1;    const cur_date=date.getDate();    const weeks_ch = ['日', '一', '二', '三', '四', '五', '六'];    //利用构造函数创建对象    function calendar(date,week){      this.date=cur_year+'-'+cur_month+'-'+date;      if(date==cur_date){        this.week = \"今天\";      }else if(date==cur_date+1){        this.week = \"明天\";      }else{        this.week = '星期' + week;      }    }    //当前月份的天数    var monthLength= getThisMonthDays(cur_year, cur_month)    //当前月份的第一天是星期几    var week = getFirstDayOfWeek(cur_year, cur_month)    var x = week;    for(var i=1;i<=monthLength;i++){      //当循环完一周后，初始化再次循环      if(x>6){        x=0;      }      //利用构造函数创建对象      that.data.calendar[i] = new calendar(i, [weeks_ch[x]][0])      x++;    }    //限制要渲染的日历数据天数为7天以内（用户体验）    var flag = that.data.calendar.splice(cur_date, that.data.calendar.length - cur_date <= 7 ? that.data.calendar.length:7)    that.setData({      calendar: flag    })    //设置scroll-view的子容器的宽度    that.setData({      width: 186 * parseInt(that.data.calendar.length - cur_date <= 7 ? that.data.calendar.length : 7)    })源代码地址https://github.com/Dorr2333/calendar-and-order.git"}
{"title": "微信小程序评分组件 ", "author": "Rolan", "pub_time": "2017-11-8 00:34", "content": "multiple-rate-wxapp微信小程序评分组件 wxapp multiple rate component下载git clone https://github.com/simsir-lin/multiple-rate-wxapp.git预览打开微信web开发者工具，'本地小程序项目 - 添加项目'，项目目录选择为 multiple-rate-wxapp 的目录就可以了，添加项目后就可以进行组件源码的查看和预览demo了。使用将 multiple-rate-wxapp 目录下的components文件夹下的multiple-rate拷贝到你的小程序目录下在你要使用的页面的json文件中引入组件，如：index页面的index.json{\r\n  \"navigationBarTitleText\": \"首页\",\r\n  \"usingComponents\": {\r\n    \"multiple-rate\": \"你的目录/multiple-rate/multiple-rate\"\r\n  }\r\n}\r\n在wxml中即可使用组件<multiple-rate rate=\"4\" disabled=\"true\"></multiple-rate>\r\n如看不明白请直接参考项目实例(/pages/index/index)注意微信小程序基础库版本至少为1.6.4贡献如果你有好的意见或建议，欢迎给我提issue!"}
